{"ast":null,"code":"import _inherits from \"/Users/Aaron/Desktop/mirrorsReactThreeFiber/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/Aaron/Desktop/mirrorsReactThreeFiber/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"/Users/Aaron/Desktop/mirrorsReactThreeFiber/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/Aaron/Desktop/mirrorsReactThreeFiber/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Original src: https://github.com/zz85/threejs-path-flow\nvar BITS = 3;\nvar TEXTURE_WIDTH = 1024;\nvar TEXTURE_HEIGHT = 4;\nimport { DataTexture, RGBFormat, FloatType, RepeatWrapping, Mesh, InstancedMesh, NearestFilter, DynamicDrawUsage, Matrix4 } from \"../../../build/three.module.js\";\n\n/**\n * Make a new DataTexture to store the descriptions of the curves.\n *\n * @param { number } numberOfCurves the number of curves needed to be described by this texture.\n */\nexport function initSplineTexture() {\n  var numberOfCurves = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  var dataArray = new Float32Array(TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * BITS);\n  var dataTexture = new DataTexture(dataArray, TEXTURE_WIDTH, TEXTURE_HEIGHT * numberOfCurves, RGBFormat, FloatType);\n  dataTexture.wrapS = RepeatWrapping;\n  dataTexture.wrapY = RepeatWrapping;\n  dataTexture.magFilter = NearestFilter;\n  dataTexture.needsUpdate = true;\n  return dataTexture;\n}\n\n/**\n * Write the curve description to the data texture\n *\n * @param { DataTexture } texture The DataTexture to write to\n * @param { Curve } splineCurve The curve to describe\n * @param { number } offset Which curve slot to write to\n */\nexport function updateSplineTexture(texture, splineCurve) {\n  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var numberOfPoints = Math.floor(TEXTURE_WIDTH * (TEXTURE_HEIGHT / 4));\n  splineCurve.arcLengthDivisions = numberOfPoints / 2;\n  splineCurve.updateArcLengths();\n  var points = splineCurve.getSpacedPoints(numberOfPoints);\n  var frenetFrames = splineCurve.computeFrenetFrames(numberOfPoints, true);\n  for (var i = 0; i < numberOfPoints; i++) {\n    var rowOffset = Math.floor(i / TEXTURE_WIDTH);\n    var rowIndex = i % TEXTURE_WIDTH;\n    var pt = points[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.tangents[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.normals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.binormals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + TEXTURE_HEIGHT * offset);\n  }\n  texture.needsUpdate = true;\n}\nfunction setTextureValue(texture, index, x, y, z, o) {\n  var image = texture.image;\n  var data = image.data;\n  var i = BITS * TEXTURE_WIDTH * o; // Row Offset\n  data[index * BITS + i + 0] = x;\n  data[index * BITS + i + 1] = y;\n  data[index * BITS + i + 2] = z;\n}\n\n/**\n * Create a new set of uniforms for describing the curve modifier\n *\n * @param { DataTexture } Texture which holds the curve description\n */\nexport function getUniforms(splineTexture) {\n  var uniforms = {\n    spineTexture: {\n      value: splineTexture\n    },\n    pathOffset: {\n      type: 'f',\n      value: 0\n    },\n    // time of path curve\n    pathSegment: {\n      type: 'f',\n      value: 1\n    },\n    // fractional length of path\n    spineOffset: {\n      type: 'f',\n      value: 161\n    },\n    spineLength: {\n      type: 'f',\n      value: 400\n    },\n    flow: {\n      type: 'i',\n      value: 1\n    }\n  };\n  return uniforms;\n}\nexport function modifyShader(material, uniforms) {\n  var numberOfCurves = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  if (material.__ok) return;\n  material.__ok = true;\n  material.onBeforeCompile = function (shader) {\n    if (shader.__modified) return;\n    shader.__modified = true;\n    Object.assign(shader.uniforms, uniforms);\n    var vertexShader = \"\\n\\t\\tuniform sampler2D spineTexture;\\n\\t\\tuniform float pathOffset;\\n\\t\\tuniform float pathSegment;\\n\\t\\tuniform float spineOffset;\\n\\t\\tuniform float spineLength;\\n\\t\\tuniform int flow;\\n\\n\\t\\tfloat textureLayers = \".concat(TEXTURE_HEIGHT * numberOfCurves, \".;\\n\\t\\tfloat textureStacks = \").concat(TEXTURE_HEIGHT / 4, \".;\\n\\n\\t\\t\").concat(shader.vertexShader, \"\\n\\t\\t\") // chunk import moved in front of modified shader below\n    .replace('#include <beginnormal_vertex>', \"\")\n\n    // vec3 transformedNormal declaration overriden below\n    .replace('#include <defaultnormal_vertex>', \"\")\n\n    // vec3 transformed declaration overriden below\n    .replace('#include <begin_vertex>', \"\")\n\n    // shader override\n    .replace(/void\\s*main\\s*\\(\\)\\s*\\{/, \"\\nvoid main() {\\n#include <beginnormal_vertex>\\n\\nvec4 worldPos = modelMatrix * vec4(position, 1.);\\n\\nbool bend = flow > 0;\\nfloat xWeight = bend ? 0. : 1.;\\n\\n#ifdef USE_INSTANCING\\nfloat pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\\nfloat spineLengthFromInstanceMatrix = instanceMatrix[3][0];\\nfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\\nfloat mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\\n#else\\nfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\\nfloat mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\\n#endif\\n\\nmt = mod(mt, textureStacks);\\nfloat rowOffset = floor(mt);\\n\\n#ifdef USE_INSTANCING\\nrowOffset += instanceMatrix[3][1] * \".concat(TEXTURE_HEIGHT, \".;\\n#endif\\n\\nvec3 spinePos = texture(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\\nvec3 a =        texture(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\\nvec3 b =        texture(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\\nvec3 c =        texture(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\\nmat3 basis = mat3(a, b, c);\\n\\nvec3 transformed = basis\\n\\t* vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\\n\\t+ spinePos;\\n\\nvec3 transformedNormal = normalMatrix * (basis * objectNormal);\\n\")).replace('#include <project_vertex>', \"\\nvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\ngl_Position = projectionMatrix * mvPosition;\\n\");\n    shader.vertexShader = vertexShader;\n  };\n}\n\n/**\n * A helper class for making meshes bend aroudn curves\n */\nexport var Flow = /*#__PURE__*/function () {\n  /**\n   * @param {Mesh} mesh The mesh to clone and modify to bend around the curve\n   * @param {number} numberOfCurves The amount of space that should preallocated for additional curves\n   */\n  function Flow(mesh) {\n    var numberOfCurves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    _classCallCheck(this, Flow);\n    var obj3D = mesh.clone();\n    var splineTexure = initSplineTexture(numberOfCurves);\n    var uniforms = getUniforms(splineTexure);\n    obj3D.traverse(function (child) {\n      if (child instanceof Mesh || child instanceof InstancedMesh) {\n        child.material = child.material.clone();\n        modifyShader(child.material, uniforms, numberOfCurves);\n      }\n    });\n    this.curveArray = new Array(numberOfCurves);\n    this.curveLengthArray = new Array(numberOfCurves);\n    this.object3D = obj3D;\n    this.splineTexure = splineTexure;\n    this.uniforms = uniforms;\n  }\n  _createClass(Flow, [{\n    key: \"updateCurve\",\n    value: function updateCurve(index, curve) {\n      if (index >= this.curveArray.length) throw Error('Index out of range for Flow');\n      var curveLength = curve.getLength();\n      this.uniforms.spineLength.value = curveLength;\n      this.curveLengthArray[index] = curveLength;\n      this.curveArray[index] = curve;\n      updateSplineTexture(this.splineTexure, curve, index);\n    }\n  }, {\n    key: \"moveAlongCurve\",\n    value: function moveAlongCurve(amount) {\n      this.uniforms.pathOffset.value += amount;\n    }\n  }]);\n  return Flow;\n}();\nvar matrix = new Matrix4();\n\n/**\n * A helper class for creating instanced versions of flow, where the instances are placed on the curve.\n */\nexport var InstancedFlow = /*#__PURE__*/function (_Flow) {\n  _inherits(InstancedFlow, _Flow);\n  var _super = _createSuper(InstancedFlow);\n  /**\n   *\n   * @param {number} count The number of instanced elements\n   * @param {number} curveCount The number of curves to preallocate for\n   * @param {Geometry} geometry The geometry to use for the instanced mesh\n   * @param {Material} material The material to use for the instanced mesh\n   */\n  function InstancedFlow(count, curveCount, geometry, material) {\n    var _this;\n    _classCallCheck(this, InstancedFlow);\n    var mesh = new InstancedMesh(geometry, material, count);\n    mesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    _this = _super.call(this, mesh, curveCount);\n    _this.offsets = new Array(count).fill(0);\n    _this.whichCurve = new Array(count).fill(0);\n    return _this;\n  }\n\n  /**\n   * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\n   * This writes that information to the matrix and marks it as needing update.\n   *\n   * @param {number} index of the instanced element to update\n   */\n  _createClass(InstancedFlow, [{\n    key: \"writeChanges\",\n    value: function writeChanges(index) {\n      matrix.makeTranslation(this.curveLengthArray[this.whichCurve[index]], this.whichCurve[index], this.offsets[index]);\n      this.object3D.setMatrixAt(index, matrix);\n      this.object3D.instanceMatrix.needsUpdate = true;\n    }\n\n    /**\n     * Move an individual element along the curve by a specific amount\n     *\n     * @param {number} index Which element to update\n     * @param {number} offset Move by how much\n     */\n  }, {\n    key: \"moveIndividualAlongCurve\",\n    value: function moveIndividualAlongCurve(index, offset) {\n      this.offsets[index] += offset;\n      this.writeChanges(index);\n    }\n\n    /**\n     * Select which curve to use for an element\n     *\n     * @param {number} index the index of the instanced element to update\n     * @param {number} curveNo the index of the curve it should use\n     */\n  }, {\n    key: \"setCurve\",\n    value: function setCurve(index, curveNo) {\n      if (isNaN(curveNo)) throw Error(\"curve index being set is Not a Number (NaN)\");\n      this.whichCurve[index] = curveNo;\n      this.writeChanges(index);\n    }\n  }]);\n  return InstancedFlow;\n}(Flow);","map":{"version":3,"names":["BITS","TEXTURE_WIDTH","TEXTURE_HEIGHT","DataTexture","RGBFormat","FloatType","RepeatWrapping","Mesh","InstancedMesh","NearestFilter","DynamicDrawUsage","Matrix4","initSplineTexture","numberOfCurves","arguments","length","undefined","dataArray","Float32Array","dataTexture","wrapS","wrapY","magFilter","needsUpdate","updateSplineTexture","texture","splineCurve","offset","numberOfPoints","Math","floor","arcLengthDivisions","updateArcLengths","points","getSpacedPoints","frenetFrames","computeFrenetFrames","i","rowOffset","rowIndex","pt","setTextureValue","x","y","z","tangents","normals","binormals","index","o","image","data","getUniforms","splineTexture","uniforms","spineTexture","value","pathOffset","type","pathSegment","spineOffset","spineLength","flow","modifyShader","material","__ok","onBeforeCompile","shader","__modified","Object","assign","vertexShader","concat","replace","Flow","mesh","_classCallCheck","obj3D","clone","splineTexure","traverse","child","curveArray","Array","curveLengthArray","object3D","_createClass","key","updateCurve","curve","Error","curveLength","getLength","moveAlongCurve","amount","matrix","InstancedFlow","_Flow","_inherits","_super","_createSuper","count","curveCount","geometry","_this","instanceMatrix","setUsage","call","offsets","fill","whichCurve","writeChanges","makeTranslation","setMatrixAt","moveIndividualAlongCurve","setCurve","curveNo","isNaN"],"sources":["/Users/Aaron/Desktop/mirrorsReactThreeFiber/node_modules/three/examples/jsm/modifiers/CurveModifier.js"],"sourcesContent":["// Original src: https://github.com/zz85/threejs-path-flow\nconst BITS = 3;\nconst TEXTURE_WIDTH = 1024;\nconst TEXTURE_HEIGHT = 4;\n\nimport {\n\tDataTexture,\n\tRGBFormat,\n\tFloatType,\n\tRepeatWrapping,\n\tMesh,\n\tInstancedMesh,\n\tNearestFilter,\n\tDynamicDrawUsage,\n\tMatrix4\n} from \"../../../build/three.module.js\";\n\n/**\n * Make a new DataTexture to store the descriptions of the curves.\n *\n * @param { number } numberOfCurves the number of curves needed to be described by this texture.\n */\nexport function initSplineTexture( numberOfCurves = 1 ) {\n\n\tconst dataArray = new Float32Array( TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * BITS );\n\tconst dataTexture = new DataTexture(\n\t\tdataArray,\n\t\tTEXTURE_WIDTH,\n\t\tTEXTURE_HEIGHT * numberOfCurves,\n\t\tRGBFormat,\n\t\tFloatType\n\t);\n\n\tdataTexture.wrapS = RepeatWrapping;\n\tdataTexture.wrapY = RepeatWrapping;\n\tdataTexture.magFilter = NearestFilter;\n\tdataTexture.needsUpdate = true;\n\n\treturn dataTexture;\n\n}\n\n/**\n * Write the curve description to the data texture\n *\n * @param { DataTexture } texture The DataTexture to write to\n * @param { Curve } splineCurve The curve to describe\n * @param { number } offset Which curve slot to write to\n */\nexport function updateSplineTexture( texture, splineCurve, offset = 0 ) {\n\n\tconst numberOfPoints = Math.floor( TEXTURE_WIDTH * ( TEXTURE_HEIGHT / 4 ) );\n\tsplineCurve.arcLengthDivisions = numberOfPoints / 2;\n\tsplineCurve.updateArcLengths();\n\tconst points = splineCurve.getSpacedPoints( numberOfPoints );\n\tconst frenetFrames = splineCurve.computeFrenetFrames( numberOfPoints, true );\n\n\tfor ( let i = 0; i < numberOfPoints; i ++ ) {\n\n\t\tconst rowOffset = Math.floor( i / TEXTURE_WIDTH );\n\t\tconst rowIndex = i % TEXTURE_WIDTH;\n\n\t\tlet pt = points[ i ];\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\n\t\tpt = frenetFrames.tangents[ i ];\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\n\t\tpt = frenetFrames.normals[ i ];\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\n\t\tpt = frenetFrames.binormals[ i ];\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\n\n\t}\n\n\ttexture.needsUpdate = true;\n\n}\n\n\nfunction setTextureValue( texture, index, x, y, z, o ) {\n\n\tconst image = texture.image;\n\tconst { data } = image;\n\tconst i = BITS * TEXTURE_WIDTH * o; // Row Offset\n\tdata[ index * BITS + i + 0 ] = x;\n\tdata[ index * BITS + i + 1 ] = y;\n\tdata[ index * BITS + i + 2 ] = z;\n\n}\n\n/**\n * Create a new set of uniforms for describing the curve modifier\n *\n * @param { DataTexture } Texture which holds the curve description\n */\nexport function getUniforms( splineTexture ) {\n\n\tconst uniforms = {\n\t\tspineTexture: { value: splineTexture },\n\t\tpathOffset: { type: 'f', value: 0 }, // time of path curve\n\t\tpathSegment: { type: 'f', value: 1 }, // fractional length of path\n\t\tspineOffset: { type: 'f', value: 161 },\n\t\tspineLength: { type: 'f', value: 400 },\n\t\tflow: { type: 'i', value: 1 },\n\t};\n\treturn uniforms;\n\n}\n\nexport function modifyShader( material, uniforms, numberOfCurves = 1 ) {\n\n\tif ( material.__ok ) return;\n\tmaterial.__ok = true;\n\n\tmaterial.onBeforeCompile = ( shader ) => {\n\n\t\tif ( shader.__modified ) return;\n\t\tshader.__modified = true;\n\n\t\tObject.assign( shader.uniforms, uniforms );\n\n\t\tconst vertexShader = `\n\t\tuniform sampler2D spineTexture;\n\t\tuniform float pathOffset;\n\t\tuniform float pathSegment;\n\t\tuniform float spineOffset;\n\t\tuniform float spineLength;\n\t\tuniform int flow;\n\n\t\tfloat textureLayers = ${TEXTURE_HEIGHT * numberOfCurves}.;\n\t\tfloat textureStacks = ${TEXTURE_HEIGHT / 4}.;\n\n\t\t${shader.vertexShader}\n\t\t`\n\t\t// chunk import moved in front of modified shader below\n\t\t.replace('#include <beginnormal_vertex>', ``)\n\n\t\t// vec3 transformedNormal declaration overriden below\n\t\t.replace('#include <defaultnormal_vertex>', ``)\n\n\t\t// vec3 transformed declaration overriden below\n\t\t.replace('#include <begin_vertex>', ``)\n\n\t\t// shader override\n\t\t.replace(\n\t\t\t/void\\s*main\\s*\\(\\)\\s*\\{/,\n`\nvoid main() {\n#include <beginnormal_vertex>\n\nvec4 worldPos = modelMatrix * vec4(position, 1.);\n\nbool bend = flow > 0;\nfloat xWeight = bend ? 0. : 1.;\n\n#ifdef USE_INSTANCING\nfloat pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\nfloat spineLengthFromInstanceMatrix = instanceMatrix[3][0];\nfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\nfloat mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\n#else\nfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\nfloat mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\n#endif\n\nmt = mod(mt, textureStacks);\nfloat rowOffset = floor(mt);\n\n#ifdef USE_INSTANCING\nrowOffset += instanceMatrix[3][1] * ${TEXTURE_HEIGHT}.;\n#endif\n\nvec3 spinePos = texture(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 a =        texture(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 b =        texture(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 c =        texture(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\nmat3 basis = mat3(a, b, c);\n\nvec3 transformed = basis\n\t* vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n\t+ spinePos;\n\nvec3 transformedNormal = normalMatrix * (basis * objectNormal);\n`).replace(\n\t'#include <project_vertex>',\n`\nvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n`\n);\n\n\t\tshader.vertexShader = vertexShader;\n\n\t};\n\n}\n\n/**\n * A helper class for making meshes bend aroudn curves\n */\nexport class Flow {\n\n\t/**\n\t * @param {Mesh} mesh The mesh to clone and modify to bend around the curve\n\t * @param {number} numberOfCurves The amount of space that should preallocated for additional curves\n\t */\n\tconstructor( mesh, numberOfCurves = 1 ) {\n\n\t\tconst obj3D = mesh.clone();\n\t\tconst splineTexure = initSplineTexture( numberOfCurves );\n\t\tconst uniforms = getUniforms( splineTexure );\n\t\tobj3D.traverse( function ( child ) {\n\n\t\t\tif (\n\t\t\t\tchild instanceof Mesh ||\n\t\t\t\tchild instanceof InstancedMesh\n\t\t\t) {\n\n\t\t\t\tchild.material = child.material.clone();\n\t\t\t\tmodifyShader( child.material, uniforms, numberOfCurves );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.curveArray = new Array( numberOfCurves );\n\t\tthis.curveLengthArray = new Array( numberOfCurves );\n\n\t\tthis.object3D = obj3D;\n\t\tthis.splineTexure = splineTexure;\n\t\tthis.uniforms = uniforms;\n\n\t}\n\n\tupdateCurve( index, curve ) {\n\n\t\tif ( index >= this.curveArray.length ) throw Error( 'Index out of range for Flow' );\n\t\tconst curveLength = curve.getLength();\n\t\tthis.uniforms.spineLength.value = curveLength;\n\t\tthis.curveLengthArray[ index ] = curveLength;\n\t\tthis.curveArray[ index ] = curve;\n\t\tupdateSplineTexture( this.splineTexure, curve, index );\n\n\t}\n\n\tmoveAlongCurve( amount ) {\n\n\t\tthis.uniforms.pathOffset.value += amount;\n\n\t}\n\n}\nconst matrix = new Matrix4();\n\n/**\n * A helper class for creating instanced versions of flow, where the instances are placed on the curve.\n */\nexport class InstancedFlow extends Flow {\n\n\t/**\n\t *\n\t * @param {number} count The number of instanced elements\n\t * @param {number} curveCount The number of curves to preallocate for\n\t * @param {Geometry} geometry The geometry to use for the instanced mesh\n\t * @param {Material} material The material to use for the instanced mesh\n\t */\n\tconstructor( count, curveCount, geometry, material ) {\n\n\t\tconst mesh = new InstancedMesh(\n\t\t\tgeometry,\n\t\t\tmaterial,\n\t\t\tcount\n\t\t);\n\t\tmesh.instanceMatrix.setUsage( DynamicDrawUsage );\n\t\tsuper( mesh, curveCount );\n\n\t\tthis.offsets = new Array( count ).fill( 0 );\n\t\tthis.whichCurve = new Array( count ).fill( 0 );\n\n\t}\n\n\t/**\n\t * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\n\t * This writes that information to the matrix and marks it as needing update.\n\t *\n\t * @param {number} index of the instanced element to update\n\t */\n\twriteChanges( index ) {\n\n\t\tmatrix.makeTranslation(\n\t\t\tthis.curveLengthArray[ this.whichCurve[ index ] ],\n\t\t\tthis.whichCurve[ index ],\n\t\t\tthis.offsets[ index ]\n\t\t);\n\t\tthis.object3D.setMatrixAt( index, matrix );\n\t\tthis.object3D.instanceMatrix.needsUpdate = true;\n\n\t}\n\n\t/**\n\t * Move an individual element along the curve by a specific amount\n\t *\n\t * @param {number} index Which element to update\n\t * @param {number} offset Move by how much\n\t */\n\tmoveIndividualAlongCurve( index, offset ) {\n\n\t\tthis.offsets[ index ] += offset;\n\t\tthis.writeChanges( index );\n\n\t}\n\n\t/**\n\t * Select which curve to use for an element\n\t *\n\t * @param {number} index the index of the instanced element to update\n\t * @param {number} curveNo the index of the curve it should use\n\t */\n\tsetCurve( index, curveNo ) {\n\n\t\tif ( isNaN( curveNo ) ) throw Error( \"curve index being set is Not a Number (NaN)\" );\n\t\tthis.whichCurve[ index ] = curveNo;\n\t\tthis.writeChanges( index );\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}