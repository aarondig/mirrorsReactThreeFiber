{"ast":null,"code":"import { InstancedInterleavedBuffer, InterleavedBufferAttribute, Line3, MathUtils, Matrix4, Mesh, Vector3, Vector4 } from \"../../../build/three.module.js\";\nimport { LineSegmentsGeometry } from \"../lines/LineSegmentsGeometry.js\";\nimport { LineMaterial } from \"../lines/LineMaterial.js\";\nvar LineSegments2 = function LineSegments2(geometry, material) {\n  if (geometry === undefined) geometry = new LineSegmentsGeometry();\n  if (material === undefined) material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  });\n  Mesh.call(this, geometry, material);\n  this.type = 'LineSegments2';\n};\nLineSegments2.prototype = Object.assign(Object.create(Mesh.prototype), {\n  constructor: LineSegments2,\n  isLineSegments2: true,\n  computeLineDistances: function () {\n    // for backwards-compatability, but could be a method of LineSegmentsGeometry...\n\n    var start = new Vector3();\n    var end = new Vector3();\n    return function computeLineDistances() {\n      var geometry = this.geometry;\n      var instanceStart = geometry.attributes.instanceStart;\n      var instanceEnd = geometry.attributes.instanceEnd;\n      var lineDistances = new Float32Array(2 * instanceStart.data.count);\n      for (var i = 0, j = 0, l = instanceStart.data.count; i < l; i++, j += 2) {\n        start.fromBufferAttribute(instanceStart, i);\n        end.fromBufferAttribute(instanceEnd, i);\n        lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n        lineDistances[j + 1] = lineDistances[j] + start.distanceTo(end);\n      }\n      var instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n      geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n      geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n      return this;\n    };\n  }(),\n  raycast: function () {\n    var start = new Vector4();\n    var end = new Vector4();\n    var ssOrigin = new Vector4();\n    var ssOrigin3 = new Vector3();\n    var mvMatrix = new Matrix4();\n    var line = new Line3();\n    var closestPoint = new Vector3();\n    return function raycast(raycaster, intersects) {\n      if (raycaster.camera === null) {\n        console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.');\n      }\n      var threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\n      var ray = raycaster.ray;\n      var camera = raycaster.camera;\n      var projectionMatrix = camera.projectionMatrix;\n      var geometry = this.geometry;\n      var material = this.material;\n      var resolution = material.resolution;\n      var lineWidth = material.linewidth + threshold;\n      var instanceStart = geometry.attributes.instanceStart;\n      var instanceEnd = geometry.attributes.instanceEnd;\n\n      // pick a point 1 unit out along the ray to avoid the ray origin\n      // sitting at the camera origin which will cause \"w\" to be 0 when\n      // applying the projection matrix.\n      ray.at(1, ssOrigin);\n\n      // ndc space [ - 1.0, 1.0 ]\n      ssOrigin.w = 1;\n      ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n      ssOrigin.applyMatrix4(projectionMatrix);\n      ssOrigin.multiplyScalar(1 / ssOrigin.w);\n\n      // screen space\n      ssOrigin.x *= resolution.x / 2;\n      ssOrigin.y *= resolution.y / 2;\n      ssOrigin.z = 0;\n      ssOrigin3.copy(ssOrigin);\n      var matrixWorld = this.matrixWorld;\n      mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n      for (var i = 0, l = instanceStart.count; i < l; i++) {\n        start.fromBufferAttribute(instanceStart, i);\n        end.fromBufferAttribute(instanceEnd, i);\n        start.w = 1;\n        end.w = 1;\n\n        // camera space\n        start.applyMatrix4(mvMatrix);\n        end.applyMatrix4(mvMatrix);\n\n        // clip space\n        start.applyMatrix4(projectionMatrix);\n        end.applyMatrix4(projectionMatrix);\n\n        // ndc space [ - 1.0, 1.0 ]\n        start.multiplyScalar(1 / start.w);\n        end.multiplyScalar(1 / end.w);\n\n        // skip the segment if it's outside the camera near and far planes\n        var isBehindCameraNear = start.z < -1 && end.z < -1;\n        var isPastCameraFar = start.z > 1 && end.z > 1;\n        if (isBehindCameraNear || isPastCameraFar) {\n          continue;\n        }\n\n        // screen space\n        start.x *= resolution.x / 2;\n        start.y *= resolution.y / 2;\n        end.x *= resolution.x / 2;\n        end.y *= resolution.y / 2;\n\n        // create 2d segment\n        line.start.copy(start);\n        line.start.z = 0;\n        line.end.copy(end);\n        line.end.z = 0;\n\n        // get closest point on ray to segment\n        var param = line.closestPointToPointParameter(ssOrigin3, true);\n        line.at(param, closestPoint);\n\n        // check if the intersection point is within clip space\n        var zPos = MathUtils.lerp(start.z, end.z, param);\n        var isInClipSpace = zPos >= -1 && zPos <= 1;\n        var isInside = ssOrigin3.distanceTo(closestPoint) < lineWidth * 0.5;\n        if (isInClipSpace && isInside) {\n          line.start.fromBufferAttribute(instanceStart, i);\n          line.end.fromBufferAttribute(instanceEnd, i);\n          line.start.applyMatrix4(matrixWorld);\n          line.end.applyMatrix4(matrixWorld);\n          var pointOnLine = new Vector3();\n          var point = new Vector3();\n          ray.distanceSqToSegment(line.start, line.end, point, pointOnLine);\n          intersects.push({\n            point: point,\n            pointOnLine: pointOnLine,\n            distance: ray.origin.distanceTo(point),\n            object: this,\n            face: null,\n            faceIndex: i,\n            uv: null,\n            uv2: null\n          });\n        }\n      }\n    };\n  }()\n});\nexport { LineSegments2 };","map":{"version":3,"names":["InstancedInterleavedBuffer","InterleavedBufferAttribute","Line3","MathUtils","Matrix4","Mesh","Vector3","Vector4","LineSegmentsGeometry","LineMaterial","LineSegments2","geometry","material","undefined","color","Math","random","call","type","prototype","Object","assign","create","constructor","isLineSegments2","computeLineDistances","start","end","instanceStart","attributes","instanceEnd","lineDistances","Float32Array","data","count","i","j","l","fromBufferAttribute","distanceTo","instanceDistanceBuffer","setAttribute","raycast","ssOrigin","ssOrigin3","mvMatrix","line","closestPoint","raycaster","intersects","camera","console","error","threshold","params","Line2","ray","projectionMatrix","resolution","lineWidth","linewidth","at","w","applyMatrix4","matrixWorldInverse","multiplyScalar","x","y","z","copy","matrixWorld","multiplyMatrices","isBehindCameraNear","isPastCameraFar","param","closestPointToPointParameter","zPos","lerp","isInClipSpace","isInside","pointOnLine","point","distanceSqToSegment","push","distance","origin","object","face","faceIndex","uv","uv2"],"sources":["/Users/Aaron/Desktop/mirrorsReactThreeFiber/node_modules/three/examples/jsm/lines/LineSegments2.js"],"sourcesContent":["import {\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tLine3,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tVector3,\n\tVector4\n} from \"../../../build/three.module.js\";\nimport { LineSegmentsGeometry } from \"../lines/LineSegmentsGeometry.js\";\nimport { LineMaterial } from \"../lines/LineMaterial.js\";\n\nvar LineSegments2 = function ( geometry, material ) {\n\n\tif ( geometry === undefined ) geometry = new LineSegmentsGeometry();\n\tif ( material === undefined ) material = new LineMaterial( { color: Math.random() * 0xffffff } );\n\n\tMesh.call( this, geometry, material );\n\n\tthis.type = 'LineSegments2';\n\n};\n\nLineSegments2.prototype = Object.assign( Object.create( Mesh.prototype ), {\n\n\tconstructor: LineSegments2,\n\n\tisLineSegments2: true,\n\n\tcomputeLineDistances: ( function () { // for backwards-compatability, but could be a method of LineSegmentsGeometry...\n\n\t\tvar start = new Vector3();\n\t\tvar end = new Vector3();\n\n\t\treturn function computeLineDistances() {\n\n\t\t\tvar geometry = this.geometry;\n\n\t\t\tvar instanceStart = geometry.attributes.instanceStart;\n\t\t\tvar instanceEnd = geometry.attributes.instanceEnd;\n\t\t\tvar lineDistances = new Float32Array( 2 * instanceStart.data.count );\n\n\t\t\tfor ( var i = 0, j = 0, l = instanceStart.data.count; i < l; i ++, j += 2 ) {\n\n\t\t\t\tstart.fromBufferAttribute( instanceStart, i );\n\t\t\t\tend.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t\tlineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];\n\t\t\t\tlineDistances[ j + 1 ] = lineDistances[ j ] + start.distanceTo( end );\n\n\t\t\t}\n\n\t\t\tvar instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1\n\n\t\t\tgeometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0\n\t\t\tgeometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}() ),\n\n\traycast: ( function () {\n\n\t\tvar start = new Vector4();\n\t\tvar end = new Vector4();\n\n\t\tvar ssOrigin = new Vector4();\n\t\tvar ssOrigin3 = new Vector3();\n\t\tvar mvMatrix = new Matrix4();\n\t\tvar line = new Line3();\n\t\tvar closestPoint = new Vector3();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tif ( raycaster.camera === null ) {\n\n\t\t\t\tconsole.error( 'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.' );\n\n\t\t\t}\n\n\t\t\tvar threshold = ( raycaster.params.Line2 !== undefined ) ? raycaster.params.Line2.threshold || 0 : 0;\n\n\t\t\tvar ray = raycaster.ray;\n\t\t\tvar camera = raycaster.camera;\n\t\t\tvar projectionMatrix = camera.projectionMatrix;\n\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar material = this.material;\n\t\t\tvar resolution = material.resolution;\n\t\t\tvar lineWidth = material.linewidth + threshold;\n\n\t\t\tvar instanceStart = geometry.attributes.instanceStart;\n\t\t\tvar instanceEnd = geometry.attributes.instanceEnd;\n\n\t\t\t// pick a point 1 unit out along the ray to avoid the ray origin\n\t\t\t// sitting at the camera origin which will cause \"w\" to be 0 when\n\t\t\t// applying the projection matrix.\n\t\t\tray.at( 1, ssOrigin );\n\n\t\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t\tssOrigin.w = 1;\n\t\t\tssOrigin.applyMatrix4( camera.matrixWorldInverse );\n\t\t\tssOrigin.applyMatrix4( projectionMatrix );\n\t\t\tssOrigin.multiplyScalar( 1 / ssOrigin.w );\n\n\t\t\t// screen space\n\t\t\tssOrigin.x *= resolution.x / 2;\n\t\t\tssOrigin.y *= resolution.y / 2;\n\t\t\tssOrigin.z = 0;\n\n\t\t\tssOrigin3.copy( ssOrigin );\n\n\t\t\tvar matrixWorld = this.matrixWorld;\n\t\t\tmvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );\n\n\t\t\tfor ( var i = 0, l = instanceStart.count; i < l; i ++ ) {\n\n\t\t\t\tstart.fromBufferAttribute( instanceStart, i );\n\t\t\t\tend.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t\tstart.w = 1;\n\t\t\t\tend.w = 1;\n\n\t\t\t\t// camera space\n\t\t\t\tstart.applyMatrix4( mvMatrix );\n\t\t\t\tend.applyMatrix4( mvMatrix );\n\n\t\t\t\t// clip space\n\t\t\t\tstart.applyMatrix4( projectionMatrix );\n\t\t\t\tend.applyMatrix4( projectionMatrix );\n\n\t\t\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t\t\tstart.multiplyScalar( 1 / start.w );\n\t\t\t\tend.multiplyScalar( 1 / end.w );\n\n\t\t\t\t// skip the segment if it's outside the camera near and far planes\n\t\t\t\tvar isBehindCameraNear = start.z < - 1 && end.z < - 1;\n\t\t\t\tvar isPastCameraFar = start.z > 1 && end.z > 1;\n\t\t\t\tif ( isBehindCameraNear || isPastCameraFar ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// screen space\n\t\t\t\tstart.x *= resolution.x / 2;\n\t\t\t\tstart.y *= resolution.y / 2;\n\n\t\t\t\tend.x *= resolution.x / 2;\n\t\t\t\tend.y *= resolution.y / 2;\n\n\t\t\t\t// create 2d segment\n\t\t\t\tline.start.copy( start );\n\t\t\t\tline.start.z = 0;\n\n\t\t\t\tline.end.copy( end );\n\t\t\t\tline.end.z = 0;\n\n\t\t\t\t// get closest point on ray to segment\n\t\t\t\tvar param = line.closestPointToPointParameter( ssOrigin3, true );\n\t\t\t\tline.at( param, closestPoint );\n\n\t\t\t\t// check if the intersection point is within clip space\n\t\t\t\tvar zPos = MathUtils.lerp( start.z, end.z, param );\n\t\t\t\tvar isInClipSpace = zPos >= - 1 && zPos <= 1;\n\n\t\t\t\tvar isInside = ssOrigin3.distanceTo( closestPoint ) < lineWidth * 0.5;\n\n\t\t\t\tif ( isInClipSpace && isInside ) {\n\n\t\t\t\t\tline.start.fromBufferAttribute( instanceStart, i );\n\t\t\t\t\tline.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t\t\tline.start.applyMatrix4( matrixWorld );\n\t\t\t\t\tline.end.applyMatrix4( matrixWorld );\n\n\t\t\t\t\tvar pointOnLine = new Vector3();\n\t\t\t\t\tvar point = new Vector3();\n\n\t\t\t\t\tray.distanceSqToSegment( line.start, line.end, point, pointOnLine );\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tpoint: point,\n\t\t\t\t\t\tpointOnLine: pointOnLine,\n\t\t\t\t\t\tdistance: ray.origin.distanceTo( point ),\n\n\t\t\t\t\t\tobject: this,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tfaceIndex: i,\n\t\t\t\t\t\tuv: null,\n\t\t\t\t\t\tuv2: null,\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() )\n\n} );\n\nexport { LineSegments2 };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}