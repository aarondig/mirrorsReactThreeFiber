{"ast":null,"code":"import _inherits from \"/Users/Aaron/Desktop/mirrorsReactThreeFiber/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/Aaron/Desktop/mirrorsReactThreeFiber/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from \"/Users/Aaron/Desktop/mirrorsReactThreeFiber/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"/Users/Aaron/Desktop/mirrorsReactThreeFiber/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/Aaron/Desktop/mirrorsReactThreeFiber/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { ShaderChunk, MathUtils, UniformsUtils, MeshDepthMaterial, RGBADepthPacking, MeshDistanceMaterial, ShaderLib, DataTexture, Vector3, Mesh, CylinderBufferGeometry, Vector2, MeshStandardMaterial, DoubleSide } from 'three';\n\n/**\r\n * Regular expression for matching the `void main() {` opener line in GLSL.\r\n * @type {RegExp}\r\n */\nvar voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n\n/**\r\n * Recursively expands all `#include <xyz>` statements within string of shader code.\r\n * Copied from three's WebGLProgram#parseIncludes for external use.\r\n *\r\n * @param {string} source - The GLSL source code to evaluate\r\n * @return {string} The GLSL code with all includes expanded\r\n */\nfunction expandShaderIncludes(source) {\n  var pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n  function replace(match, include) {\n    var chunk = ShaderChunk[include];\n    return chunk ? expandShaderIncludes(chunk) : match;\n  }\n  return source.replace(pattern, replace);\n}\n\n// Local assign polyfill to avoid importing troika-core\nvar assign = Object.assign || function /*target, ...sources*/\n() {\n  var target = arguments[0];\n  for (var i = 1, len = arguments.length; i < len; i++) {\n    var source = arguments[i];\n    if (source) {\n      for (var prop in source) {\n        if (source.hasOwnProperty(prop)) {\n          target[prop] = source[prop];\n        }\n      }\n    }\n  }\n  return target;\n};\nvar epoch = Date.now();\nvar CONSTRUCTOR_CACHE = new WeakMap();\nvar SHADER_UPGRADE_CACHE = new Map();\n\n// Material ids must be integers, but we can't access the increment from Three's `Material` module,\n// so let's choose a sufficiently large starting value that should theoretically never collide.\nvar materialInstanceId = 1e10;\n\n/**\r\n * A utility for creating a custom shader material derived from another material's\r\n * shaders. This allows you to inject custom shader logic and transforms into the\r\n * builtin ThreeJS materials without having to recreate them from scratch.\r\n *\r\n * @param {THREE.Material} baseMaterial - the original material to derive from\r\n *\r\n * @param {Object} options - How the base material should be modified.\r\n * @param {Object} options.defines - Custom `defines` for the material\r\n * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\r\n * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\r\n *        be accessed and manipulated via the resulting material's `uniforms` property, just like\r\n *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\r\n * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\r\n *        both shaders, and it will automatically be updated on each render frame with a number of\r\n *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\r\n *        true calendar time.\r\n * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\r\n *        definitions, above the `void main()` function.\r\n * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\r\n *        shader's `void main` function.\r\n * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\r\n *        shader's `void main` function.\r\n * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\r\n *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\r\n *        those attributes exposed by their normal names as read/write values.\r\n * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\r\n *        definitions, above the `void main()` function.\r\n * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\r\n *        shader's `void main` function.\r\n * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\r\n *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\r\n *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\r\n *        want those to apply to your changes use `fragmentColorTransform` instead.\r\n * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\r\n *        output value. Will be injected near the end of the `void main` function, but before any\r\n *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\r\n *        `fragmentMainOutro`.\r\n * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\r\n *        for performing custom rewrites of the full shader code. Useful if you need to do something\r\n *        special that's not covered by the other builtin options. This function will be executed before\r\n *        any other transforms are applied.\r\n * @param {boolean} options.chained - Set to `true` to prototype-chain the derived material to the base\r\n *        material, rather than the default behavior of copying it. This allows the derived material to\r\n *        automatically pick up changes made to the base material and its properties. This can be useful\r\n *        where the derived material is hidden from the user as an implementation detail, allowing them\r\n *        to work with the original material like normal. But it can result in unexpected behavior if not\r\n *        handled carefully.\r\n *\r\n * @return {THREE.Material}\r\n *\r\n * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\r\n * which can be called to get a variant of the derived material for use in shadow casting. If the\r\n * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\r\n * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\r\n * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\r\n * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\r\n * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\r\n * scenarios, e.g. skipping antialiasing or expensive shader logic.\r\n */\nfunction createDerivedMaterial(baseMaterial, options) {\n  // Generate a key that is unique to the content of these `options`. We'll use this\n  // throughout for caching and for generating the upgraded shader code. This increases\n  // the likelihood that the resulting shaders will line up across multiple calls so\n  // their GL programs can be shared and cached.\n  var optionsKey = getKeyForOptions(options);\n\n  // First check to see if we've already derived from this baseMaterial using this\n  // unique set of options, and if so reuse the constructor to avoid some allocations.\n  var ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);\n  if (!ctorsByDerivation) {\n    CONSTRUCTOR_CACHE.set(baseMaterial, ctorsByDerivation = Object.create(null));\n  }\n  if (ctorsByDerivation[optionsKey]) {\n    return new ctorsByDerivation[optionsKey]();\n  }\n  var privateBeforeCompileProp = \"_onBeforeCompile\".concat(optionsKey);\n\n  // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n  // the renderer switches to this material's program\n  var onBeforeCompile = function onBeforeCompile(shaderInfo) {\n    baseMaterial.onBeforeCompile.call(this, shaderInfo);\n\n    // Upgrade the shaders, caching the result by incoming source code\n    var cacheKey = optionsKey + '|||' + shaderInfo.vertexShader + '|||' + shaderInfo.fragmentShader;\n    var upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];\n    if (!upgradedShaders) {\n      var upgraded = upgradeShaders(shaderInfo, options, optionsKey);\n      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;\n    }\n\n    // Inject upgraded shaders and uniforms into the program\n    shaderInfo.vertexShader = upgradedShaders.vertexShader;\n    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;\n    assign(shaderInfo.uniforms, this.uniforms);\n\n    // Inject auto-updating time uniform if requested\n    if (options.timeUniform) {\n      shaderInfo.uniforms[options.timeUniform] = {\n        get value() {\n          return Date.now() - epoch;\n        }\n      };\n    }\n\n    // Users can still add their own handlers on top of ours\n    if (this[privateBeforeCompileProp]) {\n      this[privateBeforeCompileProp](shaderInfo);\n    }\n  };\n  var DerivedMaterial = function DerivedMaterial() {\n    return derive(options.chained ? baseMaterial : baseMaterial.clone());\n  };\n  var derive = function derive(base) {\n    // Prototype chain to the base material\n    var derived = Object.create(base, descriptor);\n\n    // Store the baseMaterial for reference; this is always the original even when cloning\n    Object.defineProperty(derived, 'baseMaterial', {\n      value: baseMaterial\n    });\n\n    // Needs its own ids\n    Object.defineProperty(derived, 'id', {\n      value: materialInstanceId++\n    });\n    derived.uuid = MathUtils.generateUUID();\n\n    // Merge uniforms, defines, and extensions\n    derived.uniforms = assign({}, base.uniforms, options.uniforms);\n    derived.defines = assign({}, base.defines, options.defines);\n    derived.defines[\"TROIKA_DERIVED_MATERIAL_\".concat(optionsKey)] = ''; //force a program change from the base material\n    derived.extensions = assign({}, base.extensions, options.extensions);\n\n    // Don't inherit EventDispatcher listeners\n    derived._listeners = undefined;\n    return derived;\n  };\n  var descriptor = {\n    constructor: {\n      value: DerivedMaterial\n    },\n    isDerivedMaterial: {\n      value: true\n    },\n    customProgramCacheKey: {\n      value: function value() {\n        return optionsKey;\n      }\n    },\n    onBeforeCompile: {\n      get: function get() {\n        return onBeforeCompile;\n      },\n      set: function set(fn) {\n        this[privateBeforeCompileProp] = fn;\n      }\n    },\n    copy: {\n      writable: true,\n      configurable: true,\n      value: function value(source) {\n        baseMaterial.copy.call(this, source);\n        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n          assign(this.extensions, source.extensions);\n          assign(this.defines, source.defines);\n          assign(this.uniforms, UniformsUtils.clone(source.uniforms));\n        }\n        return this;\n      }\n    },\n    clone: {\n      writable: true,\n      configurable: true,\n      value: function value() {\n        var newBase = new baseMaterial.constructor();\n        return derive(newBase).copy(this);\n      }\n    },\n    /**\r\n     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\r\n     * transformations and discarded fragments.\r\n     */\n    getDepthMaterial: {\n      writable: true,\n      configurable: true,\n      value: function value() {\n        var depthMaterial = this._depthMaterial;\n        if (!depthMaterial) {\n          depthMaterial = this._depthMaterial = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDepthMaterial() : new MeshDepthMaterial({\n            depthPacking: RGBADepthPacking\n          }), options);\n          depthMaterial.defines.IS_DEPTH_MATERIAL = '';\n          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n\n        return depthMaterial;\n      }\n    },\n    /**\r\n     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\r\n     * transformations and discarded fragments.\r\n     */\n    getDistanceMaterial: {\n      writable: true,\n      configurable: true,\n      value: function value() {\n        var distanceMaterial = this._distanceMaterial;\n        if (!distanceMaterial) {\n          distanceMaterial = this._distanceMaterial = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDistanceMaterial() : new MeshDistanceMaterial(), options);\n          distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';\n          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n\n        return distanceMaterial;\n      }\n    },\n    dispose: {\n      writable: true,\n      configurable: true,\n      value: function value() {\n        var _depthMaterial = this._depthMaterial,\n          _distanceMaterial = this._distanceMaterial;\n        if (_depthMaterial) _depthMaterial.dispose();\n        if (_distanceMaterial) _distanceMaterial.dispose();\n        baseMaterial.dispose.call(this);\n      }\n    }\n  };\n  ctorsByDerivation[optionsKey] = DerivedMaterial;\n  return new DerivedMaterial();\n}\nfunction upgradeShaders(_ref, options, key) {\n  var vertexShader = _ref.vertexShader,\n    fragmentShader = _ref.fragmentShader;\n  var vertexDefs = options.vertexDefs,\n    vertexMainIntro = options.vertexMainIntro,\n    vertexMainOutro = options.vertexMainOutro,\n    vertexTransform = options.vertexTransform,\n    fragmentDefs = options.fragmentDefs,\n    fragmentMainIntro = options.fragmentMainIntro,\n    fragmentMainOutro = options.fragmentMainOutro,\n    fragmentColorTransform = options.fragmentColorTransform,\n    customRewriter = options.customRewriter,\n    timeUniform = options.timeUniform;\n  vertexDefs = vertexDefs || '';\n  vertexMainIntro = vertexMainIntro || '';\n  vertexMainOutro = vertexMainOutro || '';\n  fragmentDefs = fragmentDefs || '';\n  fragmentMainIntro = fragmentMainIntro || '';\n  fragmentMainOutro = fragmentMainOutro || '';\n\n  // Expand includes if needed\n  if (vertexTransform || customRewriter) {\n    vertexShader = expandShaderIncludes(vertexShader);\n  }\n  if (fragmentColorTransform || customRewriter) {\n    // We need to be able to find postprocessing chunks after include expansion in order to\n    // put them after the fragmentColorTransform, so mark them with comments first. Even if\n    // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\n    // so we still mark them.\n    fragmentShader = fragmentShader.replace(/^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm, '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n');\n    fragmentShader = expandShaderIncludes(fragmentShader);\n  }\n\n  // Apply custom rewriter function\n  if (customRewriter) {\n    var res = customRewriter({\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader\n    });\n    vertexShader = res.vertexShader;\n    fragmentShader = res.fragmentShader;\n  }\n\n  // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n  // those and re-insert them into the outro in the correct place:\n  if (fragmentColorTransform) {\n    var postChunks = [];\n    fragmentShader = fragmentShader.replace(/^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm,\n    // [^]+? = non-greedy match of any chars including newlines\n    function (match) {\n      postChunks.push(match);\n      return '';\n    });\n    fragmentMainOutro = \"\".concat(fragmentColorTransform, \"\\n\").concat(postChunks.join('\\n'), \"\\n\").concat(fragmentMainOutro);\n  }\n\n  // Inject auto-updating time uniform if requested\n  if (timeUniform) {\n    var code = \"\\nuniform float \".concat(timeUniform, \";\\n\");\n    vertexDefs = code + vertexDefs;\n    fragmentDefs = code + fragmentDefs;\n  }\n\n  // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n  if (vertexTransform) {\n    vertexDefs = \"\".concat(vertexDefs, \"\\nvec3 troika_position_\").concat(key, \";\\nvec3 troika_normal_\").concat(key, \";\\nvec2 troika_uv_\").concat(key, \";\\nvoid troikaVertexTransform\").concat(key, \"(inout vec3 position, inout vec3 normal, inout vec2 uv) {\\n  \").concat(vertexTransform, \"\\n}\\n\");\n    vertexMainIntro = \"\\ntroika_position_\".concat(key, \" = vec3(position);\\ntroika_normal_\").concat(key, \" = vec3(normal);\\ntroika_uv_\").concat(key, \" = vec2(uv);\\ntroikaVertexTransform\").concat(key, \"(troika_position_\").concat(key, \", troika_normal_\").concat(key, \", troika_uv_\").concat(key, \");\\n\").concat(vertexMainIntro, \"\\n\");\n    vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, function (match, match1, index, fullStr) {\n      return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : \"troika_\".concat(match1, \"_\").concat(key);\n    });\n  }\n\n  // Inject defs and intro/outro snippets\n  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);\n  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n  return {\n    vertexShader: vertexShader,\n    fragmentShader: fragmentShader\n  };\n}\nfunction injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n  if (intro || outro || defs) {\n    shaderCode = shaderCode.replace(voidMainRegExp, \"\\n\".concat(defs, \"\\nvoid troikaOrigMain\").concat(id, \"() {\"));\n    shaderCode += \"\\nvoid main() {\\n  \".concat(intro, \"\\n  troikaOrigMain\").concat(id, \"();\\n  \").concat(outro, \"\\n}\");\n  }\n  return shaderCode;\n}\nfunction optionsJsonReplacer(key, value) {\n  return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value;\n}\nvar _idCtr = 0;\nvar optionsHashesToIds = new Map();\nfunction getKeyForOptions(options) {\n  var optionsHash = JSON.stringify(options, optionsJsonReplacer);\n  var id = optionsHashesToIds.get(optionsHash);\n  if (id == null) {\n    optionsHashesToIds.set(optionsHash, id = ++_idCtr);\n  }\n  return id;\n}\n\n// Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n// TODO how can we keep this from getting stale?\nvar MATERIAL_TYPES_TO_SHADERS = {\n  MeshDepthMaterial: 'depth',\n  MeshDistanceMaterial: 'distanceRGBA',\n  MeshNormalMaterial: 'normal',\n  MeshBasicMaterial: 'basic',\n  MeshLambertMaterial: 'lambert',\n  MeshPhongMaterial: 'phong',\n  MeshToonMaterial: 'phong',\n  MeshStandardMaterial: 'physical',\n  MeshPhysicalMaterial: 'physical',\n  MeshMatcapMaterial: 'matcap',\n  LineBasicMaterial: 'basic',\n  LineDashedMaterial: 'dashed',\n  PointsMaterial: 'points',\n  ShadowMaterial: 'shadow',\n  SpriteMaterial: 'sprite'\n};\n\n/**\r\n * Given a Three.js `Material` instance, find the shaders/uniforms that will be\r\n * used to render that material.\r\n *\r\n * @param material - the Material instance\r\n * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\r\n */\nfunction getShadersForMaterial(material) {\n  var builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n  return builtinType ? ShaderLib[builtinType] : material; //TODO fallback for unknown type?\n}\n\n/**\r\n * Find all uniforms and their types within a shader code string.\r\n *\r\n * @param {string} shader - The shader code to parse\r\n * @return {object} mapping of uniform names to their glsl type\r\n */\nfunction getShaderUniformTypes(shader) {\n  var uniformRE = /\\buniform\\s+(int|float|vec[234])\\s+([A-Za-z_][\\w]*)/g;\n  var uniforms = Object.create(null);\n  var match;\n  while ((match = uniformRE.exec(shader)) !== null) {\n    uniforms[match[2]] = match[1];\n  }\n  return uniforms;\n}\n\n/**\r\n * @class ShaderFloatArray\r\n *\r\n * When writing a custom WebGL shader, sometimes you need to pass it an array of floating\r\n * point numbers that it can read from. Unfortunately this is very difficult to do in WebGL,\r\n * because:\r\n *\r\n *   - GLSL \"array\" uniforms can only be of a constant length.\r\n *   - Textures can only hold floating point numbers in WebGL1 if the `OES_texture_float`\r\n *     extension is available.\r\n *\r\n * ShaderFloatArray is an array-like abstraction that encodes its floating point data into\r\n * an RGBA texture's four Uint8 components, and provides the corresponding ThreeJS uniforms\r\n * and GLSL code for you to put in your custom shader to query the float values by array index.\r\n *\r\n * This should generally only be used within a fragment shader, as some environments (e.g. iOS)\r\n * only allow texture lookups in fragment shaders.\r\n *\r\n * TODO:\r\n *   - Fix texture to fill both dimensions so we don't easily hit max texture size limits\r\n *   - Use a float texture if the extension is available so we can skip the encoding process\r\n */\nvar ShaderFloatArray = /*#__PURE__*/function () {\n  function ShaderFloatArray(name) {\n    _classCallCheck(this, ShaderFloatArray);\n    this.name = name;\n    this.textureUniform = \"dataTex_\".concat(name);\n    this.textureSizeUniform = \"dataTexSize_\".concat(name);\n    this.multiplierUniform = \"dataMultiplier_\".concat(name);\n\n    /**\r\n     * @property dataSizeUniform - the name of the GLSL uniform that will hold the\r\n     * length of the data array.\r\n     * @type {string}\r\n     */\n    this.dataSizeUniform = \"dataSize_\".concat(name);\n\n    /**\r\n     * @property readFunction - the name of the GLSL function that should be called to\r\n     * read data out of the array by index.\r\n     * @type {string}\r\n     */\n    this.readFunction = \"readData_\".concat(name);\n    this._raw = new Float32Array(0);\n    this._texture = new DataTexture(new Uint8Array(0), 0, 1);\n    this._length = 0;\n    this._multiplier = 1;\n  }\n\n  /**\r\n   * @property length - the current length of the data array\r\n   * @type {number}\r\n   */\n  _createClass(ShaderFloatArray, [{\n    key: \"length\",\n    get: function get() {\n      return this._length;\n    }\n\n    /**\r\n     * Add a value to the end of the data array\r\n     * @param {number} value\r\n     */,\n    set: function set(value) {\n      if (value !== this._length) {\n        // Find nearest power-of-2 that holds the new length\n        var size = Math.pow(2, Math.ceil(Math.log2(value)));\n        var raw = this._raw;\n        if (size < raw.length) {\n          this._raw = raw.subarray(0, size);\n        } else if (size > raw.length) {\n          this._raw = new Float32Array(size);\n          this._raw.set(raw);\n        }\n        this._length = value;\n      }\n    }\n  }, {\n    key: \"push\",\n    value: function push(value) {\n      return this.set(this.length++, value);\n    }\n\n    /**\r\n     * Replace the existing data with that from a new array\r\n     * @param {ArrayLike<number>} array\r\n     */\n  }, {\n    key: \"setArray\",\n    value: function setArray(array) {\n      this.length = array.length;\n      this._raw.set(array);\n      this._needsRepack = true;\n    }\n\n    /**\r\n     * Get the current value at index\r\n     * @param {number} index\r\n     * @return {number}\r\n     */\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      return this._raw[index];\n    }\n  }, {\n    key: \"set\",\n    value: function set(index, value) {\n      if (index + 1 > this._length) {\n        this.length = index + 1;\n      }\n      if (value !== this._raw[index]) {\n        this._raw[index] = value;\n        encodeFloatToFourInts(value / this._multiplier, this._texture.image.data, index * 4);\n        this._needsMultCheck = true;\n      }\n    }\n\n    /**\r\n     * Make a copy of this ShaderFloatArray\r\n     * @return {ShaderFloatArray}\r\n     */\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var clone = new ShaderFloatArray(this.name);\n      clone.setArray(this._raw);\n      return clone;\n    }\n\n    /**\r\n     * Retrieve the set of Uniforms that must to be added to the target ShaderMaterial or\r\n     * DerivedMaterial, to feed the GLSL code generated by {@link #getShaderHeaderCode}.\r\n     * @return {Object}\r\n     */\n  }, {\n    key: \"getShaderUniforms\",\n    value: function getShaderUniforms() {\n      var _ref2;\n      var me = this;\n      return _ref2 = {}, _defineProperty(_ref2, this.textureUniform, {\n        get value() {\n          me._sync();\n          return me._texture;\n        }\n      }), _defineProperty(_ref2, this.textureSizeUniform, {\n        get value() {\n          me._sync();\n          return me._texture.image.width;\n        }\n      }), _defineProperty(_ref2, this.dataSizeUniform, {\n        get value() {\n          me._sync();\n          return me.length;\n        }\n      }), _defineProperty(_ref2, this.multiplierUniform, {\n        get value() {\n          me._sync();\n          return me._multiplier;\n        }\n      }), _ref2;\n    }\n\n    /**\r\n     * Retrieve the GLSL code that must be injected into the shader's definitions area to\r\n     * enable reading from the data array. This exposes a function with a name matching\r\n     * the {@link #readFunction} property, which other shader code can call to read values\r\n     * from the array by their index.\r\n     * @return {string}\r\n     */\n  }, {\n    key: \"getShaderHeaderCode\",\n    value: function getShaderHeaderCode() {\n      var textureUniform = this.textureUniform,\n        textureSizeUniform = this.textureSizeUniform,\n        dataSizeUniform = this.dataSizeUniform,\n        multiplierUniform = this.multiplierUniform,\n        readFunction = this.readFunction;\n      return \"\\nuniform sampler2D \".concat(textureUniform, \";\\nuniform float \").concat(textureSizeUniform, \";\\nuniform float \").concat(dataSizeUniform, \";\\nuniform float \").concat(multiplierUniform, \";\\n\\nfloat \").concat(readFunction, \"(float index) {\\n  vec2 texUV = vec2((index + 0.5) / \").concat(textureSizeUniform, \", 0.5);\\n  vec4 pixel = texture2D(\").concat(textureUniform, \", texUV);\\n  return dot(pixel, 1.0 / vec4(1.0, 255.0, 65025.0, 16581375.0)) * \").concat(multiplierUniform, \";\\n}\\n\");\n    }\n\n    /**\r\n     * @private Synchronize any pending changes to the underlying DataTexture\r\n     */\n  }, {\n    key: \"_sync\",\n    value: function _sync() {\n      var tex = this._texture;\n      var raw = this._raw;\n      var needsRepack = this._needsRepack;\n\n      // If the size of the raw array changed, resize the texture to match\n      if (raw.length !== tex.image.width) {\n        tex.image = {\n          data: new Uint8Array(raw.length * 4),\n          width: raw.length,\n          height: 1\n        };\n        needsRepack = true;\n      }\n\n      // If the values changed, check the multiplier. This should be a value by which\n      // all the values are divided to constrain them to the [0,1] range required by\n      // the Uint8 packing algorithm. We pick the nearest power of 2 that holds the\n      // maximum value for greatest accuracy.\n      if (needsRepack || this._needsMultCheck) {\n        var maxVal = this._raw.reduce(function (a, b) {\n          return Math.max(a, b);\n        }, 0);\n        var mult = Math.pow(2, Math.ceil(Math.log2(maxVal)));\n        if (mult !== this._multiplier) {\n          this._multiplier = mult;\n          needsRepack = true;\n        }\n        tex.needsUpdate = true;\n        this._needsMultCheck = false;\n      }\n\n      // If things changed in a way we need to repack, do so\n      if (needsRepack) {\n        for (var i = 0, len = raw.length, _mult = this._multiplier; i < len; i++) {\n          encodeFloatToFourInts(raw[i] / _mult, tex.image.data, i * 4);\n        }\n        this._needsRepack = false;\n      }\n    }\n  }]);\n  return ShaderFloatArray;\n}();\n/**\r\n * Encode a floating point number into a set of four 8-bit integers.\r\n * Also see the companion decoder function #decodeFloatFromFourInts.\r\n *\r\n * This is adapted to JavaScript from the basic approach at\r\n * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\r\n * but writes out integers in the range 0-255 instead of floats in the range 0-1\r\n * so they can be more easily used in a Uint8Array for standard WebGL rgba textures.\r\n *\r\n * Some precision will necessarily be lost during the encoding and decoding process.\r\n * Testing shows that the maximum precision error is ~1.18e-10 which should be good\r\n * enough for most cases.\r\n *\r\n * @param {Number} value - the floating point number to encode. Must be in the range [0, 1]\r\n *        otherwise the results will be incorrect.\r\n * @param {Array|Uint8Array} array - an array into which the four ints should be written\r\n * @param {Number} startIndex - index in the output array at which to start writing the ints\r\n * @return {Array|Uint8Array}\r\n */\nfunction encodeFloatToFourInts(value, array, startIndex) {\n  // This is adapted to JS from the basic approach at\n  // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n  // but writes to a Uint8Array instead of floats. Input values must be in\n  // the range [0, 1]. The maximum error after encoding and decoding is ~1.18e-10\n  var enc0 = 255 * value;\n  var enc1 = 255 * (enc0 % 1);\n  var enc2 = 255 * (enc1 % 1);\n  var enc3 = 255 * (enc2 % 1);\n  enc0 = enc0 & 255;\n  enc1 = enc1 & 255;\n  enc2 = enc2 & 255;\n  enc3 = Math.round(enc3) & 255;\n  array[startIndex] = enc0;\n  array[startIndex + 1] = enc1;\n  array[startIndex + 2] = enc2;\n  array[startIndex + 3] = enc3;\n  return array;\n}\n\n/*\r\nInput geometry is a cylinder with r=1, height in y dimension from 0 to 1,\r\ndivided into a reasonable number of height segments.\r\n*/\n\nvar vertexDefs = \"\\nuniform vec3 pointA;\\nuniform vec3 controlA;\\nuniform vec3 controlB;\\nuniform vec3 pointB;\\nuniform float radius;\\nvarying float bezierT;\\n\\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\n  float t2 = 1.0 - t;\\n  float b0 = t2 * t2 * t2;\\n  float b1 = 3.0 * t * t2 * t2;\\n  float b2 = 3.0 * t * t * t2;\\n  float b3 = t * t * t;\\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\\n}\\n\\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\n  float t2 = 1.0 - t;\\n  return -3.0 * p1 * t2 * t2 +\\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\\n    3.0 * p2 * t * t;\\n}\\n\";\nvar vertexTransform = \"\\nfloat t = position.y;\\nbezierT = t;\\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\\n\\n// Make \\\"sideways\\\" always perpendicular to the camera ray; this ensures that any twists\\n// in the cylinder occur where you won't see them: \\nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\\nif (bezierDir == viewDirection) {\\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\\n}\\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\\nvec3 upish = normalize(cross(sideways, bezierDir));\\n\\n// Build a matrix for transforming this disc in the cylinder:\\nmat4 discTx;\\ndiscTx[0].xyz = sideways * radius;\\ndiscTx[1].xyz = bezierDir * radius;\\ndiscTx[2].xyz = upish * radius;\\ndiscTx[3].xyz = bezierCenterPos;\\ndiscTx[3][3] = 1.0;\\n\\n// Apply transform, ignoring original y\\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\\nnormal = normalize(mat3(discTx) * normal);\\n\";\nvar fragmentDefs = \"\\nuniform vec3 dashing;\\nvarying float bezierT;\\n\";\nvar fragmentMainIntro = \"\\nif (dashing.x + dashing.y > 0.0) {\\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\\n  if (dashFrac > dashing.x) {\\n    discard;\\n  }\\n}\\n\";\n\n// Debugging: separate color for each of the 6 sides:\n// const fragmentColorTransform = `\n// float sideNum = floor(vUV.x * 6.0);\n// vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n//   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n//   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n//   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n//   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n//   vec3(1.0, 0.0, 1.0);\n// gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n// `\n\nfunction createBezierMeshMaterial(baseMaterial) {\n  return createDerivedMaterial(baseMaterial, {\n    chained: true,\n    uniforms: {\n      pointA: {\n        value: new Vector3()\n      },\n      controlA: {\n        value: new Vector3()\n      },\n      controlB: {\n        value: new Vector3()\n      },\n      pointB: {\n        value: new Vector3()\n      },\n      radius: {\n        value: 0.01\n      },\n      dashing: {\n        value: new Vector3()\n      } //on, off, offset\n    },\n\n    vertexDefs: vertexDefs,\n    vertexTransform: vertexTransform,\n    fragmentDefs: fragmentDefs,\n    fragmentMainIntro: fragmentMainIntro\n  });\n}\nvar geometry = null;\nvar defaultBaseMaterial = /*#__PURE__*/new MeshStandardMaterial({\n  color: 0xffffff,\n  side: DoubleSide\n});\n\n/**\r\n * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\r\n * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\r\n * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\r\n * automatically.\r\n *\r\n * The cubiz bezier path is determined by its four `Vector3` properties:\r\n * - `pointA`\r\n * - `controlA`\r\n * - `controlB`\r\n * - `pointB`\r\n *\r\n * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\r\n *\r\n * You can also give the tube a dashed appearance with two properties:\r\n *\r\n * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\r\n *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\r\n *   used as input to the cubic bezier function, not its visible length.)\r\n * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\r\n *\r\n * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\r\n * thicker tubes.\r\n *\r\n * TODO: proper geometry bounding sphere and raycasting\r\n * TODO: allow control of the geometry's segment counts\r\n */\nvar BezierMesh = /*#__PURE__*/function (_Mesh) {\n  _inherits(BezierMesh, _Mesh);\n  var _super = _createSuper(BezierMesh);\n  function BezierMesh() {\n    var _this;\n    _classCallCheck(this, BezierMesh);\n    _this = _super.call(this, BezierMesh.getGeometry(), defaultBaseMaterial);\n    _this.pointA = new Vector3();\n    _this.controlA = new Vector3();\n    _this.controlB = new Vector3();\n    _this.pointB = new Vector3();\n    _this.radius = 0.01;\n    _this.dashArray = new Vector2();\n    _this.dashOffset = 0;\n\n    // TODO - disabling frustum culling until I figure out how to customize the\n    //  geometry's bounding sphere that gets used\n    _this.frustumCulled = false;\n    return _this;\n  }\n\n  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n  _createClass(BezierMesh, [{\n    key: \"material\",\n    get: function get() {\n      var derivedMaterial = this._derivedMaterial;\n      var baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());\n      if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n        derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);\n        // dispose the derived material when its base material is disposed:\n        baseMaterial.addEventListener('dispose', function onDispose() {\n          baseMaterial.removeEventListener('dispose', onDispose);\n          derivedMaterial.dispose();\n        });\n      }\n      return derivedMaterial;\n    },\n    set: function set(baseMaterial) {\n      this._baseMaterial = baseMaterial;\n    }\n\n    // Create and update material for shadows upon request:\n  }, {\n    key: \"customDepthMaterial\",\n    get: function get() {\n      return this.material.getDepthMaterial();\n    }\n  }, {\n    key: \"customDistanceMaterial\",\n    get: function get() {\n      return this.material.getDistanceMaterial();\n    }\n  }, {\n    key: \"onBeforeRender\",\n    value: function onBeforeRender(shaderInfo) {\n      var uniforms = this.material.uniforms;\n      var pointA = this.pointA,\n        controlA = this.controlA,\n        controlB = this.controlB,\n        pointB = this.pointB,\n        radius = this.radius,\n        dashArray = this.dashArray,\n        dashOffset = this.dashOffset;\n      uniforms.pointA.value.copy(pointA);\n      uniforms.controlA.value.copy(controlA);\n      uniforms.controlB.value.copy(controlB);\n      uniforms.pointB.value.copy(pointB);\n      uniforms.radius.value = radius;\n      uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n    }\n  }, {\n    key: \"raycast\",\n    value: function raycast(raycaster, intersects) {\n      // TODO - just fail for now\n    }\n  }], [{\n    key: \"getGeometry\",\n    value: function getGeometry() {\n      return geometry || (geometry = new CylinderBufferGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0));\n    }\n  }]);\n  return BezierMesh;\n}(Mesh);\nexport { BezierMesh, ShaderFloatArray, createDerivedMaterial, expandShaderIncludes, getShaderUniformTypes, getShadersForMaterial, voidMainRegExp };","map":{"version":3,"names":["ShaderChunk","MathUtils","UniformsUtils","MeshDepthMaterial","RGBADepthPacking","MeshDistanceMaterial","ShaderLib","DataTexture","Vector3","Mesh","CylinderBufferGeometry","Vector2","MeshStandardMaterial","DoubleSide","voidMainRegExp","expandShaderIncludes","source","pattern","replace","match","include","chunk","assign","Object","target","arguments","i","len","length","prop","hasOwnProperty","epoch","Date","now","CONSTRUCTOR_CACHE","WeakMap","SHADER_UPGRADE_CACHE","Map","materialInstanceId","createDerivedMaterial","baseMaterial","options","optionsKey","getKeyForOptions","ctorsByDerivation","get","set","create","privateBeforeCompileProp","concat","onBeforeCompile","shaderInfo","call","cacheKey","vertexShader","fragmentShader","upgradedShaders","upgraded","upgradeShaders","uniforms","timeUniform","value","DerivedMaterial","derive","chained","clone","base","derived","descriptor","defineProperty","uuid","generateUUID","defines","extensions","_listeners","undefined","constructor","isDerivedMaterial","customProgramCacheKey","fn","copy","writable","configurable","isShaderMaterial","newBase","getDepthMaterial","depthMaterial","_depthMaterial","depthPacking","IS_DEPTH_MATERIAL","getDistanceMaterial","distanceMaterial","_distanceMaterial","IS_DISTANCE_MATERIAL","dispose","_ref","key","vertexDefs","vertexMainIntro","vertexMainOutro","vertexTransform","fragmentDefs","fragmentMainIntro","fragmentMainOutro","fragmentColorTransform","customRewriter","res","postChunks","push","join","code","match1","index","fullStr","test","substr","injectIntoShaderCode","shaderCode","id","defs","intro","outro","optionsJsonReplacer","toString","_idCtr","optionsHashesToIds","optionsHash","JSON","stringify","MATERIAL_TYPES_TO_SHADERS","MeshNormalMaterial","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","MeshToonMaterial","MeshPhysicalMaterial","MeshMatcapMaterial","LineBasicMaterial","LineDashedMaterial","PointsMaterial","ShadowMaterial","SpriteMaterial","getShadersForMaterial","material","builtinType","type","getShaderUniformTypes","shader","uniformRE","exec","ShaderFloatArray","name","_classCallCheck","textureUniform","textureSizeUniform","multiplierUniform","dataSizeUniform","readFunction","_raw","Float32Array","_texture","Uint8Array","_length","_multiplier","_createClass","size","Math","pow","ceil","log2","raw","subarray","setArray","array","_needsRepack","encodeFloatToFourInts","image","data","_needsMultCheck","getShaderUniforms","_ref2","me","_defineProperty","_sync","width","getShaderHeaderCode","tex","needsRepack","height","maxVal","reduce","a","b","max","mult","needsUpdate","startIndex","enc0","enc1","enc2","enc3","round","createBezierMeshMaterial","pointA","controlA","controlB","pointB","radius","dashing","geometry","defaultBaseMaterial","color","side","BezierMesh","_Mesh","_inherits","_super","_createSuper","_this","getGeometry","dashArray","dashOffset","frustumCulled","derivedMaterial","_derivedMaterial","_baseMaterial","_defaultMaterial","addEventListener","onDispose","removeEventListener","onBeforeRender","x","y","raycast","raycaster","intersects","translate"],"sources":["/Users/Aaron/Desktop/mirrorsReactThreeFiber/node_modules/@react-three/drei/node_modules/troika-three-utils/dist/troika-three-utils.esm.js"],"sourcesContent":["import { ShaderChunk, MathUtils, UniformsUtils, MeshDepthMaterial, RGBADepthPacking, MeshDistanceMaterial, ShaderLib, DataTexture, Vector3, Mesh, CylinderBufferGeometry, Vector2, MeshStandardMaterial, DoubleSide } from 'three';\n\n/**\r\n * Regular expression for matching the `void main() {` opener line in GLSL.\r\n * @type {RegExp}\r\n */\r\nconst voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n\n/**\r\n * Recursively expands all `#include <xyz>` statements within string of shader code.\r\n * Copied from three's WebGLProgram#parseIncludes for external use.\r\n *\r\n * @param {string} source - The GLSL source code to evaluate\r\n * @return {string} The GLSL code with all includes expanded\r\n */\r\nfunction expandShaderIncludes( source ) {\r\n  const pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\r\n  function replace(match, include) {\r\n    let chunk = ShaderChunk[include];\r\n    return chunk ? expandShaderIncludes(chunk) : match\r\n  }\r\n  return source.replace( pattern, replace )\r\n}\n\n// Local assign polyfill to avoid importing troika-core\r\nconst assign = Object.assign || function(/*target, ...sources*/) {\r\n  let target = arguments[0];\r\n  for (let i = 1, len = arguments.length; i < len; i++) {\r\n    let source = arguments[i];\r\n    if (source) {\r\n      for (let prop in source) {\r\n        if (source.hasOwnProperty(prop)) {\r\n          target[prop] = source[prop];\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return target\r\n};\r\n\r\n\r\nconst epoch = Date.now();\r\nconst CONSTRUCTOR_CACHE = new WeakMap();\r\nconst SHADER_UPGRADE_CACHE = new Map();\r\n\r\n// Material ids must be integers, but we can't access the increment from Three's `Material` module,\r\n// so let's choose a sufficiently large starting value that should theoretically never collide.\r\nlet materialInstanceId = 1e10;\r\n\r\n/**\r\n * A utility for creating a custom shader material derived from another material's\r\n * shaders. This allows you to inject custom shader logic and transforms into the\r\n * builtin ThreeJS materials without having to recreate them from scratch.\r\n *\r\n * @param {THREE.Material} baseMaterial - the original material to derive from\r\n *\r\n * @param {Object} options - How the base material should be modified.\r\n * @param {Object} options.defines - Custom `defines` for the material\r\n * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\r\n * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\r\n *        be accessed and manipulated via the resulting material's `uniforms` property, just like\r\n *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\r\n * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\r\n *        both shaders, and it will automatically be updated on each render frame with a number of\r\n *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\r\n *        true calendar time.\r\n * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\r\n *        definitions, above the `void main()` function.\r\n * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\r\n *        shader's `void main` function.\r\n * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\r\n *        shader's `void main` function.\r\n * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\r\n *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\r\n *        those attributes exposed by their normal names as read/write values.\r\n * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\r\n *        definitions, above the `void main()` function.\r\n * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\r\n *        shader's `void main` function.\r\n * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\r\n *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\r\n *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\r\n *        want those to apply to your changes use `fragmentColorTransform` instead.\r\n * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\r\n *        output value. Will be injected near the end of the `void main` function, but before any\r\n *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\r\n *        `fragmentMainOutro`.\r\n * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\r\n *        for performing custom rewrites of the full shader code. Useful if you need to do something\r\n *        special that's not covered by the other builtin options. This function will be executed before\r\n *        any other transforms are applied.\r\n * @param {boolean} options.chained - Set to `true` to prototype-chain the derived material to the base\r\n *        material, rather than the default behavior of copying it. This allows the derived material to\r\n *        automatically pick up changes made to the base material and its properties. This can be useful\r\n *        where the derived material is hidden from the user as an implementation detail, allowing them\r\n *        to work with the original material like normal. But it can result in unexpected behavior if not\r\n *        handled carefully.\r\n *\r\n * @return {THREE.Material}\r\n *\r\n * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\r\n * which can be called to get a variant of the derived material for use in shadow casting. If the\r\n * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\r\n * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\r\n * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\r\n * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\r\n * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\r\n * scenarios, e.g. skipping antialiasing or expensive shader logic.\r\n */\r\nfunction createDerivedMaterial(baseMaterial, options) {\r\n  // Generate a key that is unique to the content of these `options`. We'll use this\r\n  // throughout for caching and for generating the upgraded shader code. This increases\r\n  // the likelihood that the resulting shaders will line up across multiple calls so\r\n  // their GL programs can be shared and cached.\r\n  const optionsKey = getKeyForOptions(options);\r\n\r\n  // First check to see if we've already derived from this baseMaterial using this\r\n  // unique set of options, and if so reuse the constructor to avoid some allocations.\r\n  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);\r\n  if (!ctorsByDerivation) {\r\n    CONSTRUCTOR_CACHE.set(baseMaterial, (ctorsByDerivation = Object.create(null)));\r\n  }\r\n  if (ctorsByDerivation[optionsKey]) {\r\n    return new ctorsByDerivation[optionsKey]()\r\n  }\r\n\r\n  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;\r\n\r\n  // Private onBeforeCompile handler that injects the modified shaders and uniforms when\r\n  // the renderer switches to this material's program\r\n  const onBeforeCompile = function (shaderInfo) {\r\n    baseMaterial.onBeforeCompile.call(this, shaderInfo);\r\n\r\n    // Upgrade the shaders, caching the result by incoming source code\r\n    const cacheKey = optionsKey + '|||' + shaderInfo.vertexShader + '|||' + shaderInfo.fragmentShader;\r\n    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];\r\n    if (!upgradedShaders) {\r\n      const upgraded = upgradeShaders(shaderInfo, options, optionsKey);\r\n      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;\r\n    }\r\n\r\n    // Inject upgraded shaders and uniforms into the program\r\n    shaderInfo.vertexShader = upgradedShaders.vertexShader;\r\n    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;\r\n    assign(shaderInfo.uniforms, this.uniforms);\r\n\r\n    // Inject auto-updating time uniform if requested\r\n    if (options.timeUniform) {\r\n      shaderInfo.uniforms[options.timeUniform] = {\r\n        get value() {return Date.now() - epoch}\r\n      };\r\n    }\r\n\r\n    // Users can still add their own handlers on top of ours\r\n    if (this[privateBeforeCompileProp]) {\r\n      this[privateBeforeCompileProp](shaderInfo);\r\n    }\r\n  };\r\n\r\n  const DerivedMaterial = function DerivedMaterial() {\r\n    return derive(options.chained ? baseMaterial : baseMaterial.clone())\r\n  };\r\n\r\n  const derive = function(base) {\r\n    // Prototype chain to the base material\r\n    const derived = Object.create(base, descriptor);\r\n\r\n    // Store the baseMaterial for reference; this is always the original even when cloning\r\n    Object.defineProperty(derived, 'baseMaterial', { value: baseMaterial });\r\n\r\n    // Needs its own ids\r\n    Object.defineProperty(derived, 'id', { value: materialInstanceId++ });\r\n    derived.uuid = MathUtils.generateUUID();\r\n\r\n    // Merge uniforms, defines, and extensions\r\n    derived.uniforms = assign({}, base.uniforms, options.uniforms);\r\n    derived.defines = assign({}, base.defines, options.defines);\r\n    derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = ''; //force a program change from the base material\r\n    derived.extensions = assign({}, base.extensions, options.extensions);\r\n\r\n    // Don't inherit EventDispatcher listeners\r\n    derived._listeners = undefined;\r\n\r\n    return derived\r\n  };\r\n\r\n  const descriptor = {\r\n    constructor: {value: DerivedMaterial},\r\n    isDerivedMaterial: {value: true},\r\n\r\n    customProgramCacheKey: {\r\n      value: function () {\r\n        return optionsKey\r\n      }\r\n    },\r\n\r\n    onBeforeCompile: {\r\n      get() {\r\n        return onBeforeCompile\r\n      },\r\n      set(fn) {\r\n        this[privateBeforeCompileProp] = fn;\r\n      }\r\n    },\r\n\r\n    copy: {\r\n      writable: true,\r\n      configurable: true,\r\n      value: function (source) {\r\n        baseMaterial.copy.call(this, source);\r\n        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\r\n          assign(this.extensions, source.extensions);\r\n          assign(this.defines, source.defines);\r\n          assign(this.uniforms, UniformsUtils.clone(source.uniforms));\r\n        }\r\n        return this\r\n      }\r\n    },\r\n\r\n    clone: {\r\n      writable: true,\r\n      configurable: true,\r\n      value: function () {\r\n        const newBase = new baseMaterial.constructor();\r\n        return derive(newBase).copy(this)\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\r\n     * transformations and discarded fragments.\r\n     */\r\n    getDepthMaterial: {\r\n      writable: true,\r\n      configurable: true,\r\n      value: function() {\r\n        let depthMaterial = this._depthMaterial;\r\n        if (!depthMaterial) {\r\n          depthMaterial = this._depthMaterial = createDerivedMaterial(\r\n            baseMaterial.isDerivedMaterial\r\n              ? baseMaterial.getDepthMaterial()\r\n              : new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),\r\n            options\r\n          );\r\n          depthMaterial.defines.IS_DEPTH_MATERIAL = '';\r\n          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\r\n        }\r\n        return depthMaterial\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\r\n     * transformations and discarded fragments.\r\n     */\r\n    getDistanceMaterial: {\r\n      writable: true,\r\n      configurable: true,\r\n      value: function() {\r\n        let distanceMaterial = this._distanceMaterial;\r\n        if (!distanceMaterial) {\r\n          distanceMaterial = this._distanceMaterial = createDerivedMaterial(\r\n            baseMaterial.isDerivedMaterial\r\n              ? baseMaterial.getDistanceMaterial()\r\n              : new MeshDistanceMaterial(),\r\n            options\r\n          );\r\n          distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';\r\n          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\r\n        }\r\n        return distanceMaterial\r\n      }\r\n    },\r\n\r\n    dispose: {\r\n      writable: true,\r\n      configurable: true,\r\n      value() {\r\n        const {_depthMaterial, _distanceMaterial} = this;\r\n        if (_depthMaterial) _depthMaterial.dispose();\r\n        if (_distanceMaterial) _distanceMaterial.dispose();\r\n        baseMaterial.dispose.call(this);\r\n      }\r\n    }\r\n  };\r\n\r\n  ctorsByDerivation[optionsKey] = DerivedMaterial;\r\n  return new DerivedMaterial()\r\n}\r\n\r\n\r\nfunction upgradeShaders({vertexShader, fragmentShader}, options, key) {\r\n  let {\r\n    vertexDefs,\r\n    vertexMainIntro,\r\n    vertexMainOutro,\r\n    vertexTransform,\r\n    fragmentDefs,\r\n    fragmentMainIntro,\r\n    fragmentMainOutro,\r\n    fragmentColorTransform,\r\n    customRewriter,\r\n    timeUniform\r\n  } = options;\r\n\r\n  vertexDefs = vertexDefs || '';\r\n  vertexMainIntro = vertexMainIntro || '';\r\n  vertexMainOutro = vertexMainOutro || '';\r\n  fragmentDefs = fragmentDefs || '';\r\n  fragmentMainIntro = fragmentMainIntro || '';\r\n  fragmentMainOutro = fragmentMainOutro || '';\r\n\r\n  // Expand includes if needed\r\n  if (vertexTransform || customRewriter) {\r\n    vertexShader = expandShaderIncludes(vertexShader);\r\n  }\r\n  if (fragmentColorTransform || customRewriter) {\r\n    // We need to be able to find postprocessing chunks after include expansion in order to\r\n    // put them after the fragmentColorTransform, so mark them with comments first. Even if\r\n    // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\r\n    // so we still mark them.\r\n    fragmentShader = fragmentShader.replace(\r\n      /^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,\r\n      '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n'\r\n    );\r\n    fragmentShader = expandShaderIncludes(fragmentShader);\r\n  }\r\n\r\n  // Apply custom rewriter function\r\n  if (customRewriter) {\r\n    let res = customRewriter({vertexShader, fragmentShader});\r\n    vertexShader = res.vertexShader;\r\n    fragmentShader = res.fragmentShader;\r\n  }\r\n\r\n  // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\r\n  // those and re-insert them into the outro in the correct place:\r\n  if (fragmentColorTransform) {\r\n    let postChunks = [];\r\n    fragmentShader = fragmentShader.replace(\r\n      /^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines\r\n      match => {\r\n        postChunks.push(match);\r\n        return ''\r\n      }\r\n    );\r\n    fragmentMainOutro = `${fragmentColorTransform}\\n${postChunks.join('\\n')}\\n${fragmentMainOutro}`;\r\n  }\r\n\r\n  // Inject auto-updating time uniform if requested\r\n  if (timeUniform) {\r\n    const code = `\\nuniform float ${timeUniform};\\n`;\r\n    vertexDefs = code + vertexDefs;\r\n    fragmentDefs = code + fragmentDefs;\r\n  }\r\n\r\n  // Inject a function for the vertexTransform and rename all usages of position/normal/uv\r\n  if (vertexTransform) {\r\n    vertexDefs = `${vertexDefs}\r\nvec3 troika_position_${key};\r\nvec3 troika_normal_${key};\r\nvec2 troika_uv_${key};\r\nvoid troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\r\n  ${vertexTransform}\r\n}\r\n`;\r\n    vertexMainIntro = `\r\ntroika_position_${key} = vec3(position);\r\ntroika_normal_${key} = vec3(normal);\r\ntroika_uv_${key} = vec2(uv);\r\ntroikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});\r\n${vertexMainIntro}\r\n`;\r\n    vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, (match, match1, index, fullStr) => {\r\n      return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`\r\n    });\r\n  }\r\n\r\n  // Inject defs and intro/outro snippets\r\n  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);\r\n  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\r\n\r\n  return {\r\n    vertexShader,\r\n    fragmentShader\r\n  }\r\n}\r\n\r\nfunction injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\r\n  if (intro || outro || defs) {\r\n    shaderCode = shaderCode.replace(voidMainRegExp, `\r\n${defs}\r\nvoid troikaOrigMain${id}() {`\r\n    );\r\n    shaderCode += `\r\nvoid main() {\r\n  ${intro}\r\n  troikaOrigMain${id}();\r\n  ${outro}\r\n}`;\r\n  }\r\n  return shaderCode\r\n}\r\n\r\n\r\nfunction optionsJsonReplacer(key, value) {\r\n  return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value\r\n}\r\n\r\nlet _idCtr = 0;\r\nconst optionsHashesToIds = new Map();\r\nfunction getKeyForOptions(options) {\r\n  const optionsHash = JSON.stringify(options, optionsJsonReplacer);\r\n  let id = optionsHashesToIds.get(optionsHash);\r\n  if (id == null) {\r\n    optionsHashesToIds.set(optionsHash, (id = ++_idCtr));\r\n  }\r\n  return id\r\n}\n\n// Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\r\n// TODO how can we keep this from getting stale?\r\nconst MATERIAL_TYPES_TO_SHADERS = {\r\n  MeshDepthMaterial: 'depth',\r\n  MeshDistanceMaterial: 'distanceRGBA',\r\n  MeshNormalMaterial: 'normal',\r\n  MeshBasicMaterial: 'basic',\r\n  MeshLambertMaterial: 'lambert',\r\n  MeshPhongMaterial: 'phong',\r\n  MeshToonMaterial: 'phong',\r\n  MeshStandardMaterial: 'physical',\r\n  MeshPhysicalMaterial: 'physical',\r\n  MeshMatcapMaterial: 'matcap',\r\n  LineBasicMaterial: 'basic',\r\n  LineDashedMaterial: 'dashed',\r\n  PointsMaterial: 'points',\r\n  ShadowMaterial: 'shadow',\r\n  SpriteMaterial: 'sprite'\r\n};\r\n\r\n/**\r\n * Given a Three.js `Material` instance, find the shaders/uniforms that will be\r\n * used to render that material.\r\n *\r\n * @param material - the Material instance\r\n * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\r\n */\r\nfunction getShadersForMaterial(material) {\r\n  let builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\r\n  return builtinType ? ShaderLib[builtinType] : material //TODO fallback for unknown type?\r\n}\n\n/**\r\n * Find all uniforms and their types within a shader code string.\r\n *\r\n * @param {string} shader - The shader code to parse\r\n * @return {object} mapping of uniform names to their glsl type\r\n */\r\nfunction getShaderUniformTypes(shader) {\r\n  let uniformRE = /\\buniform\\s+(int|float|vec[234])\\s+([A-Za-z_][\\w]*)/g;\r\n  let uniforms = Object.create(null);\r\n  let match;\r\n  while ((match = uniformRE.exec(shader)) !== null) {\r\n    uniforms[match[2]] = match[1];\r\n  }\r\n  return uniforms\r\n}\n\n/**\r\n * @class ShaderFloatArray\r\n *\r\n * When writing a custom WebGL shader, sometimes you need to pass it an array of floating\r\n * point numbers that it can read from. Unfortunately this is very difficult to do in WebGL,\r\n * because:\r\n *\r\n *   - GLSL \"array\" uniforms can only be of a constant length.\r\n *   - Textures can only hold floating point numbers in WebGL1 if the `OES_texture_float`\r\n *     extension is available.\r\n *\r\n * ShaderFloatArray is an array-like abstraction that encodes its floating point data into\r\n * an RGBA texture's four Uint8 components, and provides the corresponding ThreeJS uniforms\r\n * and GLSL code for you to put in your custom shader to query the float values by array index.\r\n *\r\n * This should generally only be used within a fragment shader, as some environments (e.g. iOS)\r\n * only allow texture lookups in fragment shaders.\r\n *\r\n * TODO:\r\n *   - Fix texture to fill both dimensions so we don't easily hit max texture size limits\r\n *   - Use a float texture if the extension is available so we can skip the encoding process\r\n */\r\nclass ShaderFloatArray {\r\n  constructor(name) {\r\n    this.name = name;\r\n    this.textureUniform = `dataTex_${name}`;\r\n    this.textureSizeUniform = `dataTexSize_${name}`;\r\n    this.multiplierUniform = `dataMultiplier_${name}`;\r\n\r\n    /**\r\n     * @property dataSizeUniform - the name of the GLSL uniform that will hold the\r\n     * length of the data array.\r\n     * @type {string}\r\n     */\r\n    this.dataSizeUniform = `dataSize_${name}`;\r\n\r\n    /**\r\n     * @property readFunction - the name of the GLSL function that should be called to\r\n     * read data out of the array by index.\r\n     * @type {string}\r\n     */\r\n    this.readFunction = `readData_${name}`;\r\n\r\n    this._raw = new Float32Array(0);\r\n    this._texture = new DataTexture(new Uint8Array(0), 0, 1);\r\n    this._length = 0;\r\n    this._multiplier = 1;\r\n  }\r\n\r\n  /**\r\n   * @property length - the current length of the data array\r\n   * @type {number}\r\n   */\r\n  set length(value) {\r\n    if (value !== this._length) {\r\n      // Find nearest power-of-2 that holds the new length\r\n      const size = Math.pow(2, Math.ceil(Math.log2(value)));\r\n      const raw = this._raw;\r\n      if (size < raw.length) {\r\n        this._raw = raw.subarray(0, size);\r\n      }\r\n      else if(size > raw.length) {\r\n        this._raw = new Float32Array(size);\r\n        this._raw.set(raw);\r\n      }\r\n      this._length = value;\r\n    }\r\n  }\r\n  get length() {\r\n    return this._length\r\n  }\r\n\r\n  /**\r\n   * Add a value to the end of the data array\r\n   * @param {number} value\r\n   */\r\n  push(value) {\r\n    return this.set(this.length++, value)\r\n  }\r\n\r\n  /**\r\n   * Replace the existing data with that from a new array\r\n   * @param {ArrayLike<number>} array\r\n   */\r\n  setArray(array) {\r\n    this.length = array.length;\r\n    this._raw.set(array);\r\n    this._needsRepack = true;\r\n  }\r\n\r\n  /**\r\n   * Get the current value at index\r\n   * @param {number} index\r\n   * @return {number}\r\n   */\r\n  get(index) {\r\n    return this._raw[index]\r\n  }\r\n\r\n  set(index, value) {\r\n    if (index + 1 > this._length) {\r\n      this.length = index + 1;\r\n    }\r\n    if (value !== this._raw[index]) {\r\n      this._raw[index] = value;\r\n      encodeFloatToFourInts(\r\n        value / this._multiplier,\r\n        this._texture.image.data,\r\n        index * 4\r\n      );\r\n      this._needsMultCheck = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Make a copy of this ShaderFloatArray\r\n   * @return {ShaderFloatArray}\r\n   */\r\n  clone() {\r\n    const clone = new ShaderFloatArray(this.name);\r\n    clone.setArray(this._raw);\r\n    return clone\r\n  }\r\n\r\n  /**\r\n   * Retrieve the set of Uniforms that must to be added to the target ShaderMaterial or\r\n   * DerivedMaterial, to feed the GLSL code generated by {@link #getShaderHeaderCode}.\r\n   * @return {Object}\r\n   */\r\n  getShaderUniforms() {\r\n    const me = this;\r\n    return {\r\n      [this.textureUniform]: {get value() {\r\n        me._sync();\r\n        return me._texture\r\n      }},\r\n      [this.textureSizeUniform]: {get value() {\r\n        me._sync();\r\n        return me._texture.image.width\r\n      }},\r\n      [this.dataSizeUniform]: {get value() {\r\n        me._sync();\r\n        return me.length\r\n      }},\r\n      [this.multiplierUniform]: {get value() {\r\n        me._sync();\r\n        return me._multiplier\r\n      }}\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieve the GLSL code that must be injected into the shader's definitions area to\r\n   * enable reading from the data array. This exposes a function with a name matching\r\n   * the {@link #readFunction} property, which other shader code can call to read values\r\n   * from the array by their index.\r\n   * @return {string}\r\n   */\r\n  getShaderHeaderCode() {\r\n    const {textureUniform, textureSizeUniform, dataSizeUniform, multiplierUniform, readFunction} = this;\r\n    return `\r\nuniform sampler2D ${textureUniform};\r\nuniform float ${textureSizeUniform};\r\nuniform float ${dataSizeUniform};\r\nuniform float ${multiplierUniform};\r\n\r\nfloat ${readFunction}(float index) {\r\n  vec2 texUV = vec2((index + 0.5) / ${textureSizeUniform}, 0.5);\r\n  vec4 pixel = texture2D(${textureUniform}, texUV);\r\n  return dot(pixel, 1.0 / vec4(1.0, 255.0, 65025.0, 16581375.0)) * ${multiplierUniform};\r\n}\r\n`\r\n  }\r\n\r\n  /**\r\n   * @private Synchronize any pending changes to the underlying DataTexture\r\n   */\r\n  _sync() {\r\n    const tex = this._texture;\r\n    const raw = this._raw;\r\n    let needsRepack = this._needsRepack;\r\n\r\n    // If the size of the raw array changed, resize the texture to match\r\n    if (raw.length !== tex.image.width) {\r\n      tex.image = {\r\n        data: new Uint8Array(raw.length * 4),\r\n        width: raw.length,\r\n        height: 1\r\n      };\r\n      needsRepack = true;\r\n    }\r\n\r\n    // If the values changed, check the multiplier. This should be a value by which\r\n    // all the values are divided to constrain them to the [0,1] range required by\r\n    // the Uint8 packing algorithm. We pick the nearest power of 2 that holds the\r\n    // maximum value for greatest accuracy.\r\n    if (needsRepack || this._needsMultCheck) {\r\n      const maxVal = this._raw.reduce((a, b) => Math.max(a, b), 0);\r\n      const mult = Math.pow(2, Math.ceil(Math.log2(maxVal)));\r\n      if (mult !== this._multiplier) {\r\n        this._multiplier = mult;\r\n        needsRepack = true;\r\n      }\r\n      tex.needsUpdate = true;\r\n      this._needsMultCheck = false;\r\n    }\r\n\r\n    // If things changed in a way we need to repack, do so\r\n    if (needsRepack) {\r\n      for (let i = 0, len = raw.length, mult = this._multiplier; i < len; i++) {\r\n        encodeFloatToFourInts(raw[i] / mult, tex.image.data, i * 4);\r\n      }\r\n      this._needsRepack = false;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * Encode a floating point number into a set of four 8-bit integers.\r\n * Also see the companion decoder function #decodeFloatFromFourInts.\r\n *\r\n * This is adapted to JavaScript from the basic approach at\r\n * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\r\n * but writes out integers in the range 0-255 instead of floats in the range 0-1\r\n * so they can be more easily used in a Uint8Array for standard WebGL rgba textures.\r\n *\r\n * Some precision will necessarily be lost during the encoding and decoding process.\r\n * Testing shows that the maximum precision error is ~1.18e-10 which should be good\r\n * enough for most cases.\r\n *\r\n * @param {Number} value - the floating point number to encode. Must be in the range [0, 1]\r\n *        otherwise the results will be incorrect.\r\n * @param {Array|Uint8Array} array - an array into which the four ints should be written\r\n * @param {Number} startIndex - index in the output array at which to start writing the ints\r\n * @return {Array|Uint8Array}\r\n */\r\nfunction encodeFloatToFourInts(value, array, startIndex) {\r\n  // This is adapted to JS from the basic approach at\r\n  // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\r\n  // but writes to a Uint8Array instead of floats. Input values must be in\r\n  // the range [0, 1]. The maximum error after encoding and decoding is ~1.18e-10\r\n  let enc0 = 255 * value;\r\n  let enc1 = 255 * (enc0 % 1);\r\n  let enc2 = 255 * (enc1 % 1);\r\n  let enc3 = 255 * (enc2 % 1);\r\n\r\n  enc0 = enc0 & 255;\r\n  enc1 = enc1 & 255;\r\n  enc2 = enc2 & 255;\r\n  enc3 = Math.round(enc3) & 255;\r\n\r\n  array[startIndex] = enc0;\r\n  array[startIndex + 1] = enc1;\r\n  array[startIndex + 2] = enc2;\r\n  array[startIndex + 3] = enc3;\r\n  return array\r\n}\n\n/*\r\nInput geometry is a cylinder with r=1, height in y dimension from 0 to 1,\r\ndivided into a reasonable number of height segments.\r\n*/\r\n\r\nconst vertexDefs = `\r\nuniform vec3 pointA;\r\nuniform vec3 controlA;\r\nuniform vec3 controlB;\r\nuniform vec3 pointB;\r\nuniform float radius;\r\nvarying float bezierT;\r\n\r\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\r\n  float t2 = 1.0 - t;\r\n  float b0 = t2 * t2 * t2;\r\n  float b1 = 3.0 * t * t2 * t2;\r\n  float b2 = 3.0 * t * t * t2;\r\n  float b3 = t * t * t;\r\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\r\n}\r\n\r\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\r\n  float t2 = 1.0 - t;\r\n  return -3.0 * p1 * t2 * t2 +\r\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\r\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\r\n    3.0 * p2 * t * t;\r\n}\r\n`;\r\n\r\nconst vertexTransform = `\r\nfloat t = position.y;\r\nbezierT = t;\r\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\r\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\r\n\r\n// Make \"sideways\" always perpendicular to the camera ray; this ensures that any twists\r\n// in the cylinder occur where you won't see them: \r\nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\r\nif (bezierDir == viewDirection) {\r\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\r\n}\r\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\r\nvec3 upish = normalize(cross(sideways, bezierDir));\r\n\r\n// Build a matrix for transforming this disc in the cylinder:\r\nmat4 discTx;\r\ndiscTx[0].xyz = sideways * radius;\r\ndiscTx[1].xyz = bezierDir * radius;\r\ndiscTx[2].xyz = upish * radius;\r\ndiscTx[3].xyz = bezierCenterPos;\r\ndiscTx[3][3] = 1.0;\r\n\r\n// Apply transform, ignoring original y\r\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\r\nnormal = normalize(mat3(discTx) * normal);\r\n`;\r\n\r\nconst fragmentDefs = `\r\nuniform vec3 dashing;\r\nvarying float bezierT;\r\n`;\r\n\r\nconst fragmentMainIntro = `\r\nif (dashing.x + dashing.y > 0.0) {\r\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\r\n  if (dashFrac > dashing.x) {\r\n    discard;\r\n  }\r\n}\r\n`;\r\n\r\n// Debugging: separate color for each of the 6 sides:\r\n// const fragmentColorTransform = `\r\n// float sideNum = floor(vUV.x * 6.0);\r\n// vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\r\n//   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\r\n//   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\r\n//   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\r\n//   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\r\n//   vec3(1.0, 0.0, 1.0);\r\n// gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\r\n// `\r\n\r\n\r\n\r\nfunction createBezierMeshMaterial(baseMaterial) {\r\n  return createDerivedMaterial(\r\n    baseMaterial,\r\n    {\r\n      chained: true,\r\n      uniforms: {\r\n        pointA: {value: new Vector3()},\r\n        controlA: {value: new Vector3()},\r\n        controlB: {value: new Vector3()},\r\n        pointB: {value: new Vector3()},\r\n        radius: {value: 0.01},\r\n        dashing: {value: new Vector3()} //on, off, offset\r\n      },\r\n      vertexDefs,\r\n      vertexTransform,\r\n      fragmentDefs,\r\n      fragmentMainIntro\r\n    }\r\n  )\r\n}\n\nlet geometry = null;\r\n\r\nconst defaultBaseMaterial = /*#__PURE__*/new MeshStandardMaterial({color: 0xffffff, side: DoubleSide});\r\n\r\n\r\n/**\r\n * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\r\n * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\r\n * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\r\n * automatically.\r\n *\r\n * The cubiz bezier path is determined by its four `Vector3` properties:\r\n * - `pointA`\r\n * - `controlA`\r\n * - `controlB`\r\n * - `pointB`\r\n *\r\n * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\r\n *\r\n * You can also give the tube a dashed appearance with two properties:\r\n *\r\n * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\r\n *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\r\n *   used as input to the cubic bezier function, not its visible length.)\r\n * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\r\n *\r\n * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\r\n * thicker tubes.\r\n *\r\n * TODO: proper geometry bounding sphere and raycasting\r\n * TODO: allow control of the geometry's segment counts\r\n */\r\nclass BezierMesh extends Mesh {\r\n  static getGeometry() {\r\n    return geometry || (geometry =\r\n      new CylinderBufferGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0)\r\n    )\r\n  }\r\n\r\n  constructor() {\r\n    super(\r\n      BezierMesh.getGeometry(),\r\n      defaultBaseMaterial\r\n    );\r\n\r\n    this.pointA = new Vector3();\r\n    this.controlA = new Vector3();\r\n    this.controlB = new Vector3();\r\n    this.pointB = new Vector3();\r\n    this.radius = 0.01;\r\n    this.dashArray = new Vector2();\r\n    this.dashOffset = 0;\r\n\r\n    // TODO - disabling frustum culling until I figure out how to customize the\r\n    //  geometry's bounding sphere that gets used\r\n    this.frustumCulled = false;\r\n  }\r\n\r\n  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\r\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\r\n  get material() {\r\n    let derivedMaterial = this._derivedMaterial;\r\n    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());\r\n    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\r\n      derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);\r\n      // dispose the derived material when its base material is disposed:\r\n      baseMaterial.addEventListener('dispose', function onDispose() {\r\n        baseMaterial.removeEventListener('dispose', onDispose);\r\n        derivedMaterial.dispose();\r\n      });\r\n    }\r\n    return derivedMaterial\r\n  }\r\n  set material(baseMaterial) {\r\n    this._baseMaterial = baseMaterial;\r\n  }\r\n\r\n  // Create and update material for shadows upon request:\r\n  get customDepthMaterial() {\r\n    return this.material.getDepthMaterial()\r\n  }\r\n  get customDistanceMaterial() {\r\n    return this.material.getDistanceMaterial()\r\n  }\r\n\r\n  onBeforeRender(shaderInfo) {\r\n    const {uniforms} = this.material;\r\n    const {pointA, controlA, controlB, pointB, radius, dashArray, dashOffset} = this;\r\n    uniforms.pointA.value.copy(pointA);\r\n    uniforms.controlA.value.copy(controlA);\r\n    uniforms.controlB.value.copy(controlB);\r\n    uniforms.pointB.value.copy(pointB);\r\n    uniforms.radius.value = radius;\r\n    uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\r\n  }\r\n\r\n  raycast(raycaster, intersects) {\r\n    // TODO - just fail for now\r\n  }\r\n}\n\nexport { BezierMesh, ShaderFloatArray, createDerivedMaterial, expandShaderIncludes, getShaderUniformTypes, getShadersForMaterial, voidMainRegExp };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}