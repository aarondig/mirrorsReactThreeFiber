{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/Aaron/Desktop/mirrorsReactThreeFiber/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { BufferAttribute, BufferGeometry, Vector3 } from \"../../../build/three.module.js\";\nimport { BufferGeometryUtils } from \"../utils/BufferGeometryUtils.js\";\nvar EdgeSplitModifier = function EdgeSplitModifier() {\n  var A = new Vector3();\n  var B = new Vector3();\n  var C = new Vector3();\n  var positions, normals;\n  var indexes;\n  var pointToIndexMap, splitIndexes;\n  function computeNormals() {\n    normals = new Float32Array(indexes.length * 3);\n    for (var i = 0; i < indexes.length; i += 3) {\n      var index = indexes[i];\n      A.set(positions[3 * index], positions[3 * index + 1], positions[3 * index + 2]);\n      index = indexes[i + 1];\n      B.set(positions[3 * index], positions[3 * index + 1], positions[3 * index + 2]);\n      index = indexes[i + 2];\n      C.set(positions[3 * index], positions[3 * index + 1], positions[3 * index + 2]);\n      C.sub(B);\n      A.sub(B);\n      var normal = C.cross(A).normalize();\n      for (var j = 0; j < 3; j++) {\n        normals[3 * (i + j)] = normal.x;\n        normals[3 * (i + j) + 1] = normal.y;\n        normals[3 * (i + j) + 2] = normal.z;\n      }\n    }\n  }\n  function mapPositionsToIndexes() {\n    pointToIndexMap = Array(positions.length / 3);\n    for (var i = 0; i < indexes.length; i++) {\n      var index = indexes[i];\n      if (pointToIndexMap[index] == null) {\n        pointToIndexMap[index] = [];\n      }\n      pointToIndexMap[index].push(i);\n    }\n  }\n  function edgeSplitToGroups(indexes, cutOff, firstIndex) {\n    A.set(normals[3 * firstIndex], normals[3 * firstIndex + 1], normals[3 * firstIndex + 2]).normalize();\n    var result = {\n      splitGroup: [],\n      currentGroup: [firstIndex]\n    };\n    var _iterator = _createForOfIteratorHelper(indexes),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var j = _step.value;\n        if (j !== firstIndex) {\n          B.set(normals[3 * j], normals[3 * j + 1], normals[3 * j + 2]).normalize();\n          if (B.dot(A) < cutOff) {\n            result.splitGroup.push(j);\n          } else {\n            result.currentGroup.push(j);\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return result;\n  }\n  function edgeSplit(indexes, cutOff) {\n    var original = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (indexes.length === 0) return;\n    var groupResults = [];\n    var _iterator2 = _createForOfIteratorHelper(indexes),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var index = _step2.value;\n        groupResults.push(edgeSplitToGroups(indexes, cutOff, index));\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    var result = groupResults[0];\n    for (var _i = 0, _groupResults = groupResults; _i < _groupResults.length; _i++) {\n      var groupResult = _groupResults[_i];\n      if (groupResult.currentGroup.length > result.currentGroup.length) {\n        result = groupResult;\n      }\n    }\n    if (original != null) {\n      splitIndexes.push({\n        original: original,\n        indexes: result.currentGroup\n      });\n    }\n    if (result.splitGroup.length) {\n      edgeSplit(result.splitGroup, cutOff, original || result.currentGroup[0]);\n    }\n  }\n  this.modify = function (geometry, cutOffAngle) {\n    if (!geometry.isBufferGeometry) {\n      geometry = new BufferGeometry().fromGeometry(geometry);\n    }\n    if (geometry.index == null) {\n      if (BufferGeometryUtils === undefined) {\n        throw 'THREE.EdgeSplitModifier relies on BufferGeometryUtils';\n      }\n      geometry = BufferGeometryUtils.mergeVertices(geometry);\n    }\n    indexes = geometry.index.array;\n    positions = geometry.getAttribute(\"position\").array;\n    computeNormals();\n    mapPositionsToIndexes();\n    splitIndexes = [];\n    var _iterator3 = _createForOfIteratorHelper(pointToIndexMap),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var vertexIndexes = _step3.value;\n        edgeSplit(vertexIndexes, Math.cos(cutOffAngle) - 0.001);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    var newPositions = new Float32Array(positions.length + 3 * splitIndexes.length);\n    newPositions.set(positions);\n    var offset = positions.length;\n    var newIndexes = new Uint32Array(indexes.length);\n    newIndexes.set(indexes);\n    for (var i = 0; i < splitIndexes.length; i++) {\n      var split = splitIndexes[i];\n      var index = indexes[split.original];\n      newPositions[offset + 3 * i] = positions[3 * index];\n      newPositions[offset + 3 * i + 1] = positions[3 * index + 1];\n      newPositions[offset + 3 * i + 2] = positions[3 * index + 2];\n      var _iterator4 = _createForOfIteratorHelper(split.indexes),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var j = _step4.value;\n          newIndexes[j] = offset / 3 + i;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n    geometry = new BufferGeometry();\n    geometry.setAttribute('position', new BufferAttribute(newPositions, 3, true));\n    geometry.setIndex(new BufferAttribute(newIndexes, 1));\n    return geometry;\n  };\n};\nexport { EdgeSplitModifier };","map":{"version":3,"names":["BufferAttribute","BufferGeometry","Vector3","BufferGeometryUtils","EdgeSplitModifier","A","B","C","positions","normals","indexes","pointToIndexMap","splitIndexes","computeNormals","Float32Array","length","i","index","set","sub","normal","cross","normalize","j","x","y","z","mapPositionsToIndexes","Array","push","edgeSplitToGroups","cutOff","firstIndex","result","splitGroup","currentGroup","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","dot","err","e","f","edgeSplit","original","arguments","undefined","groupResults","_iterator2","_step2","_i","_groupResults","groupResult","modify","geometry","cutOffAngle","isBufferGeometry","fromGeometry","mergeVertices","array","getAttribute","_iterator3","_step3","vertexIndexes","Math","cos","newPositions","offset","newIndexes","Uint32Array","split","_iterator4","_step4","setAttribute","setIndex"],"sources":["/Users/Aaron/Desktop/mirrorsReactThreeFiber/node_modules/three/examples/jsm/modifiers/EdgeSplitModifier.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tVector3\n} from \"../../../build/three.module.js\";\nimport { BufferGeometryUtils } from \"../utils/BufferGeometryUtils.js\";\n\n\nvar EdgeSplitModifier = function () {\n\n\tvar A = new Vector3();\n\tvar B = new Vector3();\n\tvar C = new Vector3();\n\n\tvar positions, normals;\n\tvar indexes;\n\tvar pointToIndexMap, splitIndexes;\n\n\n\tfunction computeNormals() {\n\n\t\tnormals = new Float32Array( indexes.length * 3 );\n\n\t\tfor ( var i = 0; i < indexes.length; i += 3 ) {\n\n\t\t\tvar index = indexes[ i ];\n\n\t\t\tA.set(\n\t\t\t\tpositions[ 3 * index ],\n\t\t\t\tpositions[ 3 * index + 1 ],\n\t\t\t\tpositions[ 3 * index + 2 ] );\n\n\t\t\tindex = indexes[ i + 1 ];\n\t\t\tB.set(\n\t\t\t\tpositions[ 3 * index ],\n\t\t\t\tpositions[ 3 * index + 1 ],\n\t\t\t\tpositions[ 3 * index + 2 ] );\n\n\t\t\tindex = indexes[ i + 2 ];\n\t\t\tC.set(\n\t\t\t\tpositions[ 3 * index ],\n\t\t\t\tpositions[ 3 * index + 1 ],\n\t\t\t\tpositions[ 3 * index + 2 ] );\n\n\t\t\tC.sub( B );\n\t\t\tA.sub( B );\n\n\t\t\tvar normal = C.cross( A ).normalize();\n\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\tnormals[ 3 * ( i + j ) ] = normal.x;\n\t\t\t\tnormals[ 3 * ( i + j ) + 1 ] = normal.y;\n\t\t\t\tnormals[ 3 * ( i + j ) + 2 ] = normal.z;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\tfunction mapPositionsToIndexes() {\n\n\t\tpointToIndexMap = Array( positions.length / 3 );\n\n\t\tfor ( var i = 0; i < indexes.length; i ++ ) {\n\n\t\t\tvar index = indexes[ i ];\n\n\t\t\tif ( pointToIndexMap[ index ] == null ) {\n\n\t\t\t\tpointToIndexMap[ index ] = [];\n\n\t\t\t}\n\n\t\t\tpointToIndexMap[ index ].push( i );\n\n\t\t}\n\n\t}\n\n\n\tfunction edgeSplitToGroups( indexes, cutOff, firstIndex ) {\n\n\t\tA.set( normals[ 3 * firstIndex ], normals[ 3 * firstIndex + 1 ], normals[ 3 * firstIndex + 2 ] ).normalize();\n\n\t\tvar result = {\n\t\t\tsplitGroup: [],\n\t\t\tcurrentGroup: [ firstIndex ]\n\t\t};\n\n\t\tfor ( var j of indexes ) {\n\n\t\t\tif ( j !== firstIndex ) {\n\n\t\t\t\tB.set( normals[ 3 * j ], normals[ 3 * j + 1 ], normals[ 3 * j + 2 ] ).normalize();\n\n\t\t\t\tif ( B.dot( A ) < cutOff ) {\n\n\t\t\t\t\tresult.splitGroup.push( j );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresult.currentGroup.push( j );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\n\tfunction edgeSplit( indexes, cutOff, original = null ) {\n\n\t\tif ( indexes.length === 0 ) return;\n\n\t\tvar groupResults = [];\n\n\t\tfor ( var index of indexes ) {\n\n\t\t\tgroupResults.push( edgeSplitToGroups( indexes, cutOff, index ) );\n\n\t\t}\n\n\t\tvar result = groupResults[ 0 ];\n\n\t\tfor ( var groupResult of groupResults ) {\n\n\t\t\tif ( groupResult.currentGroup.length > result.currentGroup.length ) {\n\n\t\t\t\tresult = groupResult;\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tif ( original != null ) {\n\n\t\t\tsplitIndexes.push( {\n\t\t\t\toriginal: original,\n\t\t\t\tindexes: result.currentGroup\n\t\t\t} );\n\n\t\t}\n\n\t\tif ( result.splitGroup.length ) {\n\n\t\t\tedgeSplit( result.splitGroup, cutOff, original || result.currentGroup[ 0 ] );\n\n\t\t}\n\n\t}\n\n\n\tthis.modify = function ( geometry, cutOffAngle ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tgeometry = new BufferGeometry().fromGeometry( geometry );\n\n\t\t}\n\n\n\t\tif ( geometry.index == null ) {\n\n\t\t\tif ( BufferGeometryUtils === undefined ) {\n\n\t\t\t \tthrow 'THREE.EdgeSplitModifier relies on BufferGeometryUtils';\n\n\t\t\t}\n\n\t\t\tgeometry = BufferGeometryUtils.mergeVertices( geometry );\n\n\t\t}\n\n\t\tindexes = geometry.index.array;\n\t\tpositions = geometry.getAttribute( \"position\" ).array;\n\n\t\tcomputeNormals();\n\t\tmapPositionsToIndexes();\n\n\n\t\tsplitIndexes = [];\n\n\t\tfor ( var vertexIndexes of pointToIndexMap ) {\n\n\t\t\tedgeSplit( vertexIndexes, Math.cos( cutOffAngle ) - 0.001 );\n\n\t\t}\n\n\t\tvar newPositions = new Float32Array( positions.length + 3 * splitIndexes.length );\n\t\tnewPositions.set( positions );\n\t\tvar offset = positions.length;\n\n\t\tvar newIndexes = new Uint32Array( indexes.length );\n\t\tnewIndexes.set( indexes );\n\n\t\tfor ( var i = 0; i < splitIndexes.length; i ++ ) {\n\n\t\t\tvar split = splitIndexes[ i ];\n\t\t\tvar index = indexes[ split.original ];\n\n\t\t\tnewPositions[ offset + 3 * i ] = positions[ 3 * index ];\n\t\t\tnewPositions[ offset + 3 * i + 1 ] = positions[ 3 * index + 1 ];\n\t\t\tnewPositions[ offset + 3 * i + 2 ] = positions[ 3 * index + 2 ];\n\n\t\t\tfor ( var j of split.indexes ) {\n\n\t\t\t\tnewIndexes[ j ] = offset / 3 + i;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new BufferAttribute( newPositions, 3, true ) );\n\t\tgeometry.setIndex( new BufferAttribute( newIndexes, 1 ) );\n\n\t\treturn geometry;\n\n\t};\n\n};\n\nexport { EdgeSplitModifier };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}