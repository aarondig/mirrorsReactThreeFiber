{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport { ShaderChunk } from 'three';\nvar pcss = function pcss() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n    _ref$frustrum = _ref.frustrum,\n    frustrum = _ref$frustrum === void 0 ? 3.75 : _ref$frustrum,\n    _ref$size = _ref.size,\n    size = _ref$size === void 0 ? 0.005 : _ref$size,\n    _ref$near = _ref.near,\n    near = _ref$near === void 0 ? 9.5 : _ref$near,\n    _ref$samples = _ref.samples,\n    samples = _ref$samples === void 0 ? 17 : _ref$samples,\n    _ref$rings = _ref.rings,\n    rings = _ref$rings === void 0 ? 11 : _ref$rings;\n  return \"#define LIGHT_WORLD_SIZE \" + size + \"\\n#define LIGHT_FRUSTUM_WIDTH \" + frustrum + \"\\n#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\\n#define NEAR_PLANE \" + near + \"\\n\\n#define NUM_SAMPLES \" + samples + \"\\n#define NUM_RINGS \" + rings + \"\\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\\n#define PCF_NUM_SAMPLES NUM_SAMPLES\\n\\nvec2 poissonDisk[NUM_SAMPLES];\\n\\nvoid initPoissonSamples(const in vec2 randomSeed) {\\n\\tfloat ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\\n\\tfloat INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\\n\\tfloat angle = rand(randomSeed) * PI2;\\n\\tfloat radius = INV_NUM_SAMPLES;\\n\\tfloat radiusStep = radius;\\n\\tfor (int i = 0; i < NUM_SAMPLES; i++) {\\n\\t\\tpoissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\\n\\t\\tradius += radiusStep;\\n\\t\\tangle += ANGLE_STEP;\\n\\t}\\n}\\n\\nfloat penumbraSize(const in float zReceiver, const in float zBlocker) { // Parallel plane estimation\\n\\treturn (zReceiver - zBlocker) / zBlocker;\\n}\\n\\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver) {\\n\\tfloat searchRadius = LIGHT_SIZE_UV * (zReceiver - NEAR_PLANE) / zReceiver;\\n\\tfloat blockerDepthSum = 0.0;\\n\\tint numBlockers = 0;\\n\\tfor (int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++) {\\n\\t\\tfloat shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\\n\\t\\tif (shadowMapDepth < zReceiver) {\\n\\t\\t\\tblockerDepthSum += shadowMapDepth;\\n\\t\\t\\tnumBlockers++;\\n\\t\\t}\\n\\t}\\n\\tif (numBlockers == 0) return -1.0;\\n\\treturn blockerDepthSum / float(numBlockers);\\n}\\n\\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\\n\\tfloat sum = 0.0;\\n\\tfor (int i = 0; i < PCF_NUM_SAMPLES; i++) {\\n\\t\\tfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[ i ] * filterRadius));\\n\\t\\tif (zReceiver <= depth) sum += 1.0;\\n\\t}\\n\\tfor (int i = 0; i < PCF_NUM_SAMPLES; i++) {\\n\\t\\tfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[ i ].yx * filterRadius));\\n\\t\\tif (zReceiver <= depth) sum += 1.0;\\n\\t}\\n\\treturn sum / (2.0 * float(PCF_NUM_SAMPLES));\\n}\\n\\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\\n\\tvec2 uv = coords.xy;\\n\\tfloat zReceiver = coords.z; // Assumed to be eye-space z in this code\\n\\tinitPoissonSamples(uv);\\n\\tfloat avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\\n\\tif (avgBlockerDepth == -1.0) return 1.0;\\n\\tfloat penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\\n\\tfloat filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\\n\\treturn PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\\n}\";\n};\nvar deployed = false;\nvar softShadows = function softShadows(props) {\n  // Avoid adding the effect twice, which may happen in HMR scenarios\n  if (!deployed) {\n    deployed = true;\n    var shader = ShaderChunk.shadowmap_pars_fragment;\n    shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP\\n' + pcss(_extends({}, props)));\n    shader = shader.replace('#if defined( SHADOWMAP_TYPE_PCF )', '\\nreturn PCSS(shadowMap, shadowCoord);\\n#if defined( SHADOWMAP_TYPE_PCF )');\n    ShaderChunk.shadowmap_pars_fragment = shader;\n  }\n};\nexport { softShadows };","map":{"version":3,"names":["_extends","ShaderChunk","pcss","_ref","arguments","length","undefined","_ref$frustrum","frustrum","_ref$size","size","_ref$near","near","_ref$samples","samples","_ref$rings","rings","deployed","softShadows","props","shader","shadowmap_pars_fragment","replace"],"sources":["/Users/Aaron/Desktop/mirrorsReactThreeFiber/node_modules/@react-three/drei/softShadows.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport { ShaderChunk } from 'three';\n\nconst pcss = ({\n  frustrum = 3.75,\n  size = 0.005,\n  near = 9.5,\n  samples = 17,\n  rings = 11\n} = {}) => \"#define LIGHT_WORLD_SIZE \" + size + \"\\n#define LIGHT_FRUSTUM_WIDTH \" + frustrum + \"\\n#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\\n#define NEAR_PLANE \" + near + \"\\n\\n#define NUM_SAMPLES \" + samples + \"\\n#define NUM_RINGS \" + rings + \"\\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\\n#define PCF_NUM_SAMPLES NUM_SAMPLES\\n\\nvec2 poissonDisk[NUM_SAMPLES];\\n\\nvoid initPoissonSamples(const in vec2 randomSeed) {\\n\\tfloat ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\\n\\tfloat INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\\n\\tfloat angle = rand(randomSeed) * PI2;\\n\\tfloat radius = INV_NUM_SAMPLES;\\n\\tfloat radiusStep = radius;\\n\\tfor (int i = 0; i < NUM_SAMPLES; i++) {\\n\\t\\tpoissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\\n\\t\\tradius += radiusStep;\\n\\t\\tangle += ANGLE_STEP;\\n\\t}\\n}\\n\\nfloat penumbraSize(const in float zReceiver, const in float zBlocker) { // Parallel plane estimation\\n\\treturn (zReceiver - zBlocker) / zBlocker;\\n}\\n\\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver) {\\n\\tfloat searchRadius = LIGHT_SIZE_UV * (zReceiver - NEAR_PLANE) / zReceiver;\\n\\tfloat blockerDepthSum = 0.0;\\n\\tint numBlockers = 0;\\n\\tfor (int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++) {\\n\\t\\tfloat shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\\n\\t\\tif (shadowMapDepth < zReceiver) {\\n\\t\\t\\tblockerDepthSum += shadowMapDepth;\\n\\t\\t\\tnumBlockers++;\\n\\t\\t}\\n\\t}\\n\\tif (numBlockers == 0) return -1.0;\\n\\treturn blockerDepthSum / float(numBlockers);\\n}\\n\\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\\n\\tfloat sum = 0.0;\\n\\tfor (int i = 0; i < PCF_NUM_SAMPLES; i++) {\\n\\t\\tfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[ i ] * filterRadius));\\n\\t\\tif (zReceiver <= depth) sum += 1.0;\\n\\t}\\n\\tfor (int i = 0; i < PCF_NUM_SAMPLES; i++) {\\n\\t\\tfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[ i ].yx * filterRadius));\\n\\t\\tif (zReceiver <= depth) sum += 1.0;\\n\\t}\\n\\treturn sum / (2.0 * float(PCF_NUM_SAMPLES));\\n}\\n\\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\\n\\tvec2 uv = coords.xy;\\n\\tfloat zReceiver = coords.z; // Assumed to be eye-space z in this code\\n\\tinitPoissonSamples(uv);\\n\\tfloat avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\\n\\tif (avgBlockerDepth == -1.0) return 1.0;\\n\\tfloat penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\\n\\tfloat filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\\n\\treturn PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\\n}\";\n\nlet deployed = false;\nconst softShadows = props => {\n  // Avoid adding the effect twice, which may happen in HMR scenarios\n  if (!deployed) {\n    deployed = true;\n    let shader = ShaderChunk.shadowmap_pars_fragment;\n    shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP\\n' + pcss(_extends({}, props)));\n    shader = shader.replace('#if defined( SHADOWMAP_TYPE_PCF )', '\\nreturn PCSS(shadowMap, shadowCoord);\\n#if defined( SHADOWMAP_TYPE_PCF )');\n    ShaderChunk.shadowmap_pars_fragment = shader;\n  }\n};\n\nexport { softShadows };\n"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,oCAAoC;AACzD,SAASC,WAAW,QAAQ,OAAO;AAEnC,IAAMC,IAAI,GAAG,SAAPA,IAAIA,CAAA;EAAA,IAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAMN,CAAC,CAAC;IAAAG,aAAA,GAAAJ,IAAA,CALJK,QAAQ;IAARA,QAAQ,GAAAD,aAAA,cAAG,IAAI,GAAAA,aAAA;IAAAE,SAAA,GAAAN,IAAA,CACfO,IAAI;IAAJA,IAAI,GAAAD,SAAA,cAAG,KAAK,GAAAA,SAAA;IAAAE,SAAA,GAAAR,IAAA,CACZS,IAAI;IAAJA,IAAI,GAAAD,SAAA,cAAG,GAAG,GAAAA,SAAA;IAAAE,YAAA,GAAAV,IAAA,CACVW,OAAO;IAAPA,OAAO,GAAAD,YAAA,cAAG,EAAE,GAAAA,YAAA;IAAAE,UAAA,GAAAZ,IAAA,CACZa,KAAK;IAALA,KAAK,GAAAD,UAAA,cAAG,EAAE,GAAAA,UAAA;EAAA,OACD,2BAA2B,GAAGL,IAAI,GAAG,gCAAgC,GAAGF,QAAQ,GAAG,uFAAuF,GAAGI,IAAI,GAAG,0BAA0B,GAAGE,OAAO,GAAG,sBAAsB,GAAGE,KAAK,GAAG,yzEAAyzE;AAAA;AAEhkF,IAAIC,QAAQ,GAAG,KAAK;AACpB,IAAMC,WAAW,GAAG,SAAdA,WAAWA,CAAGC,KAAK,EAAI;EAC3B;EACA,IAAI,CAACF,QAAQ,EAAE;IACbA,QAAQ,GAAG,IAAI;IACf,IAAIG,MAAM,GAAGnB,WAAW,CAACoB,uBAAuB;IAChDD,MAAM,GAAGA,MAAM,CAACE,OAAO,CAAC,sBAAsB,EAAE,wBAAwB,GAAGpB,IAAI,CAACF,QAAQ,CAAC,CAAC,CAAC,EAAEmB,KAAK,CAAC,CAAC,CAAC;IACrGC,MAAM,GAAGA,MAAM,CAACE,OAAO,CAAC,mCAAmC,EAAE,2EAA2E,CAAC;IACzIrB,WAAW,CAACoB,uBAAuB,GAAGD,MAAM;EAC9C;AACF,CAAC;AAED,SAASF,WAAW"},"metadata":{},"sourceType":"module"}