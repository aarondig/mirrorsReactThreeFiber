{"ast":null,"code":"import { BufferGeometry, Face3, Geometry, Vector2, Vector3 } from \"../../../build/three.module.js\";\n\n/**\n *\tSubdivision Geometry Modifier\n *\t\tusing Loop Subdivision Scheme\n *\n *\tReferences:\n *\t\thttp://graphics.stanford.edu/~mdfisher/subdivision.html\n *\t\thttp://www.holmes3d.net/graphics/subdivision/\n *\t\thttp://www.cs.rutgers.edu/~decarlo/readings/subdiv-sg00c.pdf\n *\n *\tKnown Issues:\n *\t\t- currently doesn't handle \"Sharp Edges\"\n */\n\nvar SubdivisionModifier = function SubdivisionModifier(subdivisions) {\n  this.subdivisions = subdivisions === undefined ? 1 : subdivisions;\n};\n\n// Applies the \"modify\" pattern\nSubdivisionModifier.prototype.modify = function (geometry) {\n  var isBufferGeometry = geometry.isBufferGeometry;\n  if (isBufferGeometry) {\n    geometry = new Geometry().fromBufferGeometry(geometry);\n  } else {\n    geometry = geometry.clone();\n  }\n  geometry.mergeVertices(6);\n  var repeats = this.subdivisions;\n  while (repeats-- > 0) {\n    this.smooth(geometry);\n  }\n  geometry.computeFaceNormals();\n  geometry.computeVertexNormals();\n  if (isBufferGeometry) {\n    return new BufferGeometry().fromGeometry(geometry);\n  } else {\n    return geometry;\n  }\n};\n(function () {\n  // Some constants\n  var ABC = ['a', 'b', 'c'];\n  function getEdge(a, b, map) {\n    var vertexIndexA = Math.min(a, b);\n    var vertexIndexB = Math.max(a, b);\n    var key = vertexIndexA + \"_\" + vertexIndexB;\n    return map[key];\n  }\n  function processEdge(a, b, vertices, map, face, metaVertices) {\n    var vertexIndexA = Math.min(a, b);\n    var vertexIndexB = Math.max(a, b);\n    var key = vertexIndexA + \"_\" + vertexIndexB;\n    var edge;\n    if (key in map) {\n      edge = map[key];\n    } else {\n      var vertexA = vertices[vertexIndexA];\n      var vertexB = vertices[vertexIndexB];\n      edge = {\n        a: vertexA,\n        // pointer reference\n        b: vertexB,\n        newEdge: null,\n        // aIndex: a, // numbered reference\n        // bIndex: b,\n        faces: [] // pointers to face\n      };\n\n      map[key] = edge;\n    }\n    edge.faces.push(face);\n    metaVertices[a].edges.push(edge);\n    metaVertices[b].edges.push(edge);\n  }\n  function generateLookups(vertices, faces, metaVertices, edges) {\n    var i, il, face;\n    for (i = 0, il = vertices.length; i < il; i++) {\n      metaVertices[i] = {\n        edges: []\n      };\n    }\n    for (i = 0, il = faces.length; i < il; i++) {\n      face = faces[i];\n      processEdge(face.a, face.b, vertices, edges, face, metaVertices);\n      processEdge(face.b, face.c, vertices, edges, face, metaVertices);\n      processEdge(face.c, face.a, vertices, edges, face, metaVertices);\n    }\n  }\n  function newFace(newFaces, a, b, c, materialIndex) {\n    newFaces.push(new Face3(a, b, c, undefined, undefined, materialIndex));\n  }\n  function midpoint(a, b) {\n    return Math.abs(b - a) / 2 + Math.min(a, b);\n  }\n  function newUv(newUvs, a, b, c) {\n    newUvs.push([a.clone(), b.clone(), c.clone()]);\n  }\n\n  /////////////////////////////\n\n  // Performs one iteration of Subdivision\n  SubdivisionModifier.prototype.smooth = function (geometry) {\n    var tmp = new Vector3();\n    var oldVertices, oldFaces, oldUvs;\n    var newVertices,\n      newFaces,\n      newUVs = [];\n    var n, i, il, j, k;\n    var metaVertices, sourceEdges;\n\n    // new stuff.\n    var sourceEdges, newEdgeVertices, newSourceVertices;\n    oldVertices = geometry.vertices; // { x, y, z}\n    oldFaces = geometry.faces; // { a: oldVertex1, b: oldVertex2, c: oldVertex3 }\n    oldUvs = geometry.faceVertexUvs;\n    var hasUvs = oldUvs[0] !== undefined && oldUvs[0].length > 0;\n    if (hasUvs) {\n      for (var j = 0; j < oldUvs.length; j++) {\n        newUVs.push([]);\n      }\n    }\n\n    /******************************************************\n     *\n     * Step 0: Preprocess Geometry to Generate edges Lookup\n     *\n     *******************************************************/\n\n    metaVertices = new Array(oldVertices.length);\n    sourceEdges = {}; // Edge => { oldVertex1, oldVertex2, faces[]  }\n\n    generateLookups(oldVertices, oldFaces, metaVertices, sourceEdges);\n\n    /******************************************************\n     *\n     *\tStep 1.\n     *\tFor each edge, create a new Edge Vertex,\n     *\tthen position it.\n     *\n     *******************************************************/\n\n    newEdgeVertices = [];\n    var other, currentEdge, newEdge, face;\n    var edgeVertexWeight, adjacentVertexWeight, connectedFaces;\n    for (i in sourceEdges) {\n      currentEdge = sourceEdges[i];\n      newEdge = new Vector3();\n      edgeVertexWeight = 3 / 8;\n      adjacentVertexWeight = 1 / 8;\n      connectedFaces = currentEdge.faces.length;\n\n      // check how many linked faces. 2 should be correct.\n      if (connectedFaces != 2) {\n        // if length is not 2, handle condition\n        edgeVertexWeight = 0.5;\n        adjacentVertexWeight = 0;\n        if (connectedFaces != 1) {\n\n          // console.warn( 'Subdivision Modifier: Number of connected faces != 2, is: ', connectedFaces, currentEdge );\n        }\n      }\n      newEdge.addVectors(currentEdge.a, currentEdge.b).multiplyScalar(edgeVertexWeight);\n      tmp.set(0, 0, 0);\n      for (j = 0; j < connectedFaces; j++) {\n        face = currentEdge.faces[j];\n        for (k = 0; k < 3; k++) {\n          other = oldVertices[face[ABC[k]]];\n          if (other !== currentEdge.a && other !== currentEdge.b) break;\n        }\n        tmp.add(other);\n      }\n      tmp.multiplyScalar(adjacentVertexWeight);\n      newEdge.add(tmp);\n      currentEdge.newEdge = newEdgeVertices.length;\n      newEdgeVertices.push(newEdge);\n\n      // console.log(currentEdge, newEdge);\n    }\n\n    /******************************************************\n     *\n     *\tStep 2.\n     *\tReposition each source vertices.\n     *\n     *******************************************************/\n\n    var beta, sourceVertexWeight, connectingVertexWeight;\n    var connectingEdge, connectingEdges, oldVertex, newSourceVertex;\n    newSourceVertices = [];\n    for (i = 0, il = oldVertices.length; i < il; i++) {\n      oldVertex = oldVertices[i];\n\n      // find all connecting edges (using lookupTable)\n      connectingEdges = metaVertices[i].edges;\n      n = connectingEdges.length;\n      if (n == 3) {\n        beta = 3 / 16;\n      } else if (n > 3) {\n        beta = 3 / (8 * n); // Warren's modified formula\n      }\n\n      // Loop's original beta formula\n      // beta = 1 / n * ( 5/8 - Math.pow( 3/8 + 1/4 * Math.cos( 2 * Math. PI / n ), 2) );\n\n      sourceVertexWeight = 1 - n * beta;\n      connectingVertexWeight = beta;\n      if (n <= 2) {\n        // crease and boundary rules\n        // console.warn('crease and boundary rules');\n\n        if (n == 2) {\n          // console.warn( '2 connecting edges', connectingEdges );\n          sourceVertexWeight = 3 / 4;\n          connectingVertexWeight = 1 / 8;\n\n          // sourceVertexWeight = 1;\n          // connectingVertexWeight = 0;\n        } else if (n == 1) {\n\n          // console.warn( 'only 1 connecting edge' );\n        } else if (n == 0) {\n\n          // console.warn( '0 connecting edges' );\n        }\n      }\n      newSourceVertex = oldVertex.clone().multiplyScalar(sourceVertexWeight);\n      tmp.set(0, 0, 0);\n      for (j = 0; j < n; j++) {\n        connectingEdge = connectingEdges[j];\n        other = connectingEdge.a !== oldVertex ? connectingEdge.a : connectingEdge.b;\n        tmp.add(other);\n      }\n      tmp.multiplyScalar(connectingVertexWeight);\n      newSourceVertex.add(tmp);\n      newSourceVertices.push(newSourceVertex);\n    }\n\n    /******************************************************\n     *\n     *\tStep 3.\n     *\tGenerate Faces between source vertices\n     *\tand edge vertices.\n     *\n     *******************************************************/\n\n    newVertices = newSourceVertices.concat(newEdgeVertices);\n    var sl = newSourceVertices.length,\n      edge1,\n      edge2,\n      edge3;\n    newFaces = [];\n    var uv, x0, x1, x2;\n    var x3 = new Vector2();\n    var x4 = new Vector2();\n    var x5 = new Vector2();\n    for (i = 0, il = oldFaces.length; i < il; i++) {\n      face = oldFaces[i];\n\n      // find the 3 new edges vertex of each old face\n\n      edge1 = getEdge(face.a, face.b, sourceEdges).newEdge + sl;\n      edge2 = getEdge(face.b, face.c, sourceEdges).newEdge + sl;\n      edge3 = getEdge(face.c, face.a, sourceEdges).newEdge + sl;\n\n      // create 4 faces.\n\n      newFace(newFaces, edge1, edge2, edge3, face.materialIndex);\n      newFace(newFaces, face.a, edge1, edge3, face.materialIndex);\n      newFace(newFaces, face.b, edge2, edge1, face.materialIndex);\n      newFace(newFaces, face.c, edge3, edge2, face.materialIndex);\n\n      // create 4 new uv's\n\n      if (hasUvs) {\n        for (var j = 0; j < oldUvs.length; j++) {\n          uv = oldUvs[j][i];\n          x0 = uv[0];\n          x1 = uv[1];\n          x2 = uv[2];\n          x3.set(midpoint(x0.x, x1.x), midpoint(x0.y, x1.y));\n          x4.set(midpoint(x1.x, x2.x), midpoint(x1.y, x2.y));\n          x5.set(midpoint(x0.x, x2.x), midpoint(x0.y, x2.y));\n          newUv(newUVs[j], x3, x4, x5);\n          newUv(newUVs[j], x0, x3, x5);\n          newUv(newUVs[j], x1, x4, x3);\n          newUv(newUVs[j], x2, x5, x4);\n        }\n      }\n    }\n\n    // Overwrite old arrays\n    geometry.vertices = newVertices;\n    geometry.faces = newFaces;\n    if (hasUvs) geometry.faceVertexUvs = newUVs;\n\n    // console.log('done');\n  };\n})();\n\nexport { SubdivisionModifier };","map":{"version":3,"names":["BufferGeometry","Face3","Geometry","Vector2","Vector3","SubdivisionModifier","subdivisions","undefined","prototype","modify","geometry","isBufferGeometry","fromBufferGeometry","clone","mergeVertices","repeats","smooth","computeFaceNormals","computeVertexNormals","fromGeometry","ABC","getEdge","a","b","map","vertexIndexA","Math","min","vertexIndexB","max","key","processEdge","vertices","face","metaVertices","edge","vertexA","vertexB","newEdge","faces","push","edges","generateLookups","i","il","length","c","newFace","newFaces","materialIndex","midpoint","abs","newUv","newUvs","tmp","oldVertices","oldFaces","oldUvs","newVertices","newUVs","n","j","k","sourceEdges","newEdgeVertices","newSourceVertices","faceVertexUvs","hasUvs","Array","other","currentEdge","edgeVertexWeight","adjacentVertexWeight","connectedFaces","addVectors","multiplyScalar","set","add","beta","sourceVertexWeight","connectingVertexWeight","connectingEdge","connectingEdges","oldVertex","newSourceVertex","concat","sl","edge1","edge2","edge3","uv","x0","x1","x2","x3","x4","x5","x","y"],"sources":["/Users/Aaron/Desktop/mirrorsReactThreeFiber/node_modules/three/examples/jsm/modifiers/SubdivisionModifier.js"],"sourcesContent":["import {\n\tBufferGeometry,\n\tFace3,\n\tGeometry,\n\tVector2,\n\tVector3\n} from \"../../../build/three.module.js\";\n\n/**\n *\tSubdivision Geometry Modifier\n *\t\tusing Loop Subdivision Scheme\n *\n *\tReferences:\n *\t\thttp://graphics.stanford.edu/~mdfisher/subdivision.html\n *\t\thttp://www.holmes3d.net/graphics/subdivision/\n *\t\thttp://www.cs.rutgers.edu/~decarlo/readings/subdiv-sg00c.pdf\n *\n *\tKnown Issues:\n *\t\t- currently doesn't handle \"Sharp Edges\"\n */\n\nvar SubdivisionModifier = function ( subdivisions ) {\n\n\tthis.subdivisions = ( subdivisions === undefined ) ? 1 : subdivisions;\n\n};\n\n// Applies the \"modify\" pattern\nSubdivisionModifier.prototype.modify = function ( geometry ) {\n\n\tvar isBufferGeometry = geometry.isBufferGeometry;\n\n\tif ( isBufferGeometry ) {\n\n\t\tgeometry = new Geometry().fromBufferGeometry( geometry );\n\n\t} else {\n\n\t\tgeometry = geometry.clone();\n\n\t}\n\n\tgeometry.mergeVertices( 6 );\n\n\tvar repeats = this.subdivisions;\n\n\twhile ( repeats -- > 0 ) {\n\n\t\tthis.smooth( geometry );\n\n\t}\n\n\tgeometry.computeFaceNormals();\n\tgeometry.computeVertexNormals();\n\n\tif ( isBufferGeometry ) {\n\n\t\treturn new BufferGeometry().fromGeometry( geometry );\n\n\t} else {\n\n\t\treturn geometry;\n\n\t}\n\n};\n\n( function () {\n\n\t// Some constants\n\tvar ABC = [ 'a', 'b', 'c' ];\n\n\n\tfunction getEdge( a, b, map ) {\n\n\t\tvar vertexIndexA = Math.min( a, b );\n\t\tvar vertexIndexB = Math.max( a, b );\n\n\t\tvar key = vertexIndexA + \"_\" + vertexIndexB;\n\n\t\treturn map[ key ];\n\n\t}\n\n\n\tfunction processEdge( a, b, vertices, map, face, metaVertices ) {\n\n\t\tvar vertexIndexA = Math.min( a, b );\n\t\tvar vertexIndexB = Math.max( a, b );\n\n\t\tvar key = vertexIndexA + \"_\" + vertexIndexB;\n\n\t\tvar edge;\n\n\t\tif ( key in map ) {\n\n\t\t\tedge = map[ key ];\n\n\t\t} else {\n\n\t\t\tvar vertexA = vertices[ vertexIndexA ];\n\t\t\tvar vertexB = vertices[ vertexIndexB ];\n\n\t\t\tedge = {\n\n\t\t\t\ta: vertexA, // pointer reference\n\t\t\t\tb: vertexB,\n\t\t\t\tnewEdge: null,\n\t\t\t\t// aIndex: a, // numbered reference\n\t\t\t\t// bIndex: b,\n\t\t\t\tfaces: [] // pointers to face\n\n\t\t\t};\n\n\t\t\tmap[ key ] = edge;\n\n\t\t}\n\n\t\tedge.faces.push( face );\n\n\t\tmetaVertices[ a ].edges.push( edge );\n\t\tmetaVertices[ b ].edges.push( edge );\n\n\n\t}\n\n\tfunction generateLookups( vertices, faces, metaVertices, edges ) {\n\n\t\tvar i, il, face;\n\n\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tmetaVertices[ i ] = { edges: [] };\n\n\t\t}\n\n\t\tfor ( i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\tface = faces[ i ];\n\n\t\t\tprocessEdge( face.a, face.b, vertices, edges, face, metaVertices );\n\t\t\tprocessEdge( face.b, face.c, vertices, edges, face, metaVertices );\n\t\t\tprocessEdge( face.c, face.a, vertices, edges, face, metaVertices );\n\n\t\t}\n\n\t}\n\n\tfunction newFace( newFaces, a, b, c, materialIndex ) {\n\n\t\tnewFaces.push( new Face3( a, b, c, undefined, undefined, materialIndex ) );\n\n\t}\n\n\tfunction midpoint( a, b ) {\n\n\t\treturn ( Math.abs( b - a ) / 2 ) + Math.min( a, b );\n\n\t}\n\n\tfunction newUv( newUvs, a, b, c ) {\n\n\t\tnewUvs.push( [ a.clone(), b.clone(), c.clone() ] );\n\n\t}\n\n\t/////////////////////////////\n\n\t// Performs one iteration of Subdivision\n\tSubdivisionModifier.prototype.smooth = function ( geometry ) {\n\n\t\tvar tmp = new Vector3();\n\n\t\tvar oldVertices, oldFaces, oldUvs;\n\t\tvar newVertices, newFaces, newUVs = [];\n\n\t\tvar n, i, il, j, k;\n\t\tvar metaVertices, sourceEdges;\n\n\t\t// new stuff.\n\t\tvar sourceEdges, newEdgeVertices, newSourceVertices;\n\n\t\toldVertices = geometry.vertices; // { x, y, z}\n\t\toldFaces = geometry.faces; // { a: oldVertex1, b: oldVertex2, c: oldVertex3 }\n\t\toldUvs = geometry.faceVertexUvs;\n\n\t\tvar hasUvs = oldUvs[ 0 ] !== undefined && oldUvs[ 0 ].length > 0;\n\n\t\tif ( hasUvs ) {\n\n\t\t\tfor ( var j = 0; j < oldUvs.length; j ++ ) {\n\n\t\t\t\tnewUVs.push( [] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/******************************************************\n\t\t *\n\t\t * Step 0: Preprocess Geometry to Generate edges Lookup\n\t\t *\n\t\t *******************************************************/\n\n\t\tmetaVertices = new Array( oldVertices.length );\n\t\tsourceEdges = {}; // Edge => { oldVertex1, oldVertex2, faces[]  }\n\n\t\tgenerateLookups( oldVertices, oldFaces, metaVertices, sourceEdges );\n\n\n\t\t/******************************************************\n\t\t *\n\t\t *\tStep 1.\n\t\t *\tFor each edge, create a new Edge Vertex,\n\t\t *\tthen position it.\n\t\t *\n\t\t *******************************************************/\n\n\t\tnewEdgeVertices = [];\n\t\tvar other, currentEdge, newEdge, face;\n\t\tvar edgeVertexWeight, adjacentVertexWeight, connectedFaces;\n\n\t\tfor ( i in sourceEdges ) {\n\n\t\t\tcurrentEdge = sourceEdges[ i ];\n\t\t\tnewEdge = new Vector3();\n\n\t\t\tedgeVertexWeight = 3 / 8;\n\t\t\tadjacentVertexWeight = 1 / 8;\n\n\t\t\tconnectedFaces = currentEdge.faces.length;\n\n\t\t\t// check how many linked faces. 2 should be correct.\n\t\t\tif ( connectedFaces != 2 ) {\n\n\t\t\t\t// if length is not 2, handle condition\n\t\t\t\tedgeVertexWeight = 0.5;\n\t\t\t\tadjacentVertexWeight = 0;\n\n\t\t\t\tif ( connectedFaces != 1 ) {\n\n\t\t\t\t\t// console.warn( 'Subdivision Modifier: Number of connected faces != 2, is: ', connectedFaces, currentEdge );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnewEdge.addVectors( currentEdge.a, currentEdge.b ).multiplyScalar( edgeVertexWeight );\n\n\t\t\ttmp.set( 0, 0, 0 );\n\n\t\t\tfor ( j = 0; j < connectedFaces; j ++ ) {\n\n\t\t\t\tface = currentEdge.faces[ j ];\n\n\t\t\t\tfor ( k = 0; k < 3; k ++ ) {\n\n\t\t\t\t\tother = oldVertices[ face[ ABC[ k ] ] ];\n\t\t\t\t\tif ( other !== currentEdge.a && other !== currentEdge.b ) break;\n\n\t\t\t\t}\n\n\t\t\t\ttmp.add( other );\n\n\t\t\t}\n\n\t\t\ttmp.multiplyScalar( adjacentVertexWeight );\n\t\t\tnewEdge.add( tmp );\n\n\t\t\tcurrentEdge.newEdge = newEdgeVertices.length;\n\t\t\tnewEdgeVertices.push( newEdge );\n\n\t\t\t// console.log(currentEdge, newEdge);\n\n\t\t}\n\n\t\t/******************************************************\n\t\t *\n\t\t *\tStep 2.\n\t\t *\tReposition each source vertices.\n\t\t *\n\t\t *******************************************************/\n\n\t\tvar beta, sourceVertexWeight, connectingVertexWeight;\n\t\tvar connectingEdge, connectingEdges, oldVertex, newSourceVertex;\n\t\tnewSourceVertices = [];\n\n\t\tfor ( i = 0, il = oldVertices.length; i < il; i ++ ) {\n\n\t\t\toldVertex = oldVertices[ i ];\n\n\t\t\t// find all connecting edges (using lookupTable)\n\t\t\tconnectingEdges = metaVertices[ i ].edges;\n\t\t\tn = connectingEdges.length;\n\n\t\t\tif ( n == 3 ) {\n\n\t\t\t\tbeta = 3 / 16;\n\n\t\t\t} else if ( n > 3 ) {\n\n\t\t\t\tbeta = 3 / ( 8 * n ); // Warren's modified formula\n\n\t\t\t}\n\n\t\t\t// Loop's original beta formula\n\t\t\t// beta = 1 / n * ( 5/8 - Math.pow( 3/8 + 1/4 * Math.cos( 2 * Math. PI / n ), 2) );\n\n\t\t\tsourceVertexWeight = 1 - n * beta;\n\t\t\tconnectingVertexWeight = beta;\n\n\t\t\tif ( n <= 2 ) {\n\n\t\t\t\t// crease and boundary rules\n\t\t\t\t// console.warn('crease and boundary rules');\n\n\t\t\t\tif ( n == 2 ) {\n\n\t\t\t\t\t// console.warn( '2 connecting edges', connectingEdges );\n\t\t\t\t\tsourceVertexWeight = 3 / 4;\n\t\t\t\t\tconnectingVertexWeight = 1 / 8;\n\n\t\t\t\t\t// sourceVertexWeight = 1;\n\t\t\t\t\t// connectingVertexWeight = 0;\n\n\t\t\t\t} else if ( n == 1 ) {\n\n\t\t\t\t\t// console.warn( 'only 1 connecting edge' );\n\n\t\t\t\t} else if ( n == 0 ) {\n\n\t\t\t\t\t// console.warn( '0 connecting edges' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnewSourceVertex = oldVertex.clone().multiplyScalar( sourceVertexWeight );\n\n\t\t\ttmp.set( 0, 0, 0 );\n\n\t\t\tfor ( j = 0; j < n; j ++ ) {\n\n\t\t\t\tconnectingEdge = connectingEdges[ j ];\n\t\t\t\tother = connectingEdge.a !== oldVertex ? connectingEdge.a : connectingEdge.b;\n\t\t\t\ttmp.add( other );\n\n\t\t\t}\n\n\t\t\ttmp.multiplyScalar( connectingVertexWeight );\n\t\t\tnewSourceVertex.add( tmp );\n\n\t\t\tnewSourceVertices.push( newSourceVertex );\n\n\t\t}\n\n\n\t\t/******************************************************\n\t\t *\n\t\t *\tStep 3.\n\t\t *\tGenerate Faces between source vertices\n\t\t *\tand edge vertices.\n\t\t *\n\t\t *******************************************************/\n\n\t\tnewVertices = newSourceVertices.concat( newEdgeVertices );\n\t\tvar sl = newSourceVertices.length, edge1, edge2, edge3;\n\t\tnewFaces = [];\n\n\t\tvar uv, x0, x1, x2;\n\t\tvar x3 = new Vector2();\n\t\tvar x4 = new Vector2();\n\t\tvar x5 = new Vector2();\n\n\t\tfor ( i = 0, il = oldFaces.length; i < il; i ++ ) {\n\n\t\t\tface = oldFaces[ i ];\n\n\t\t\t// find the 3 new edges vertex of each old face\n\n\t\t\tedge1 = getEdge( face.a, face.b, sourceEdges ).newEdge + sl;\n\t\t\tedge2 = getEdge( face.b, face.c, sourceEdges ).newEdge + sl;\n\t\t\tedge3 = getEdge( face.c, face.a, sourceEdges ).newEdge + sl;\n\n\t\t\t// create 4 faces.\n\n\t\t\tnewFace( newFaces, edge1, edge2, edge3, face.materialIndex );\n\t\t\tnewFace( newFaces, face.a, edge1, edge3, face.materialIndex );\n\t\t\tnewFace( newFaces, face.b, edge2, edge1, face.materialIndex );\n\t\t\tnewFace( newFaces, face.c, edge3, edge2, face.materialIndex );\n\n\t\t\t// create 4 new uv's\n\n\t\t\tif ( hasUvs ) {\n\n\t\t\t\tfor ( var j = 0; j < oldUvs.length; j ++ ) {\n\n\t\t\t\t\tuv = oldUvs[ j ][ i ];\n\n\t\t\t\t\tx0 = uv[ 0 ];\n\t\t\t\t\tx1 = uv[ 1 ];\n\t\t\t\t\tx2 = uv[ 2 ];\n\n\t\t\t\t\tx3.set( midpoint( x0.x, x1.x ), midpoint( x0.y, x1.y ) );\n\t\t\t\t\tx4.set( midpoint( x1.x, x2.x ), midpoint( x1.y, x2.y ) );\n\t\t\t\t\tx5.set( midpoint( x0.x, x2.x ), midpoint( x0.y, x2.y ) );\n\n\t\t\t\t\tnewUv( newUVs[ j ], x3, x4, x5 );\n\t\t\t\t\tnewUv( newUVs[ j ], x0, x3, x5 );\n\n\t\t\t\t\tnewUv( newUVs[ j ], x1, x4, x3 );\n\t\t\t\t\tnewUv( newUVs[ j ], x2, x5, x4 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Overwrite old arrays\n\t\tgeometry.vertices = newVertices;\n\t\tgeometry.faces = newFaces;\n\t\tif ( hasUvs ) geometry.faceVertexUvs = newUVs;\n\n\t\t// console.log('done');\n\n\t};\n\n} )();\n\nexport { SubdivisionModifier };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}