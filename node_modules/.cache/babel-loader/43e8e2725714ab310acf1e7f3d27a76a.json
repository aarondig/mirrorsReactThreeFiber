{"ast":null,"code":"import { BufferAttribute, BufferGeometry, InterleavedBuffer, InterleavedBufferAttribute, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, Vector2, Vector3 } from \"../../../build/three.module.js\";\nvar BufferGeometryUtils = {\n  computeTangents: function computeTangents(geometry) {\n    var index = geometry.index;\n    var attributes = geometry.attributes;\n\n    // based on http://www.terathon.com/code/tangent.html\n    // (per vertex tangents)\n\n    if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {\n      console.error('THREE.BufferGeometryUtils: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');\n      return;\n    }\n    var indices = index.array;\n    var positions = attributes.position.array;\n    var normals = attributes.normal.array;\n    var uvs = attributes.uv.array;\n    var nVertices = positions.length / 3;\n    if (attributes.tangent === undefined) {\n      geometry.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));\n    }\n    var tangents = attributes.tangent.array;\n    var tan1 = [],\n      tan2 = [];\n    for (var i = 0; i < nVertices; i++) {\n      tan1[i] = new Vector3();\n      tan2[i] = new Vector3();\n    }\n    var vA = new Vector3(),\n      vB = new Vector3(),\n      vC = new Vector3(),\n      uvA = new Vector2(),\n      uvB = new Vector2(),\n      uvC = new Vector2(),\n      sdir = new Vector3(),\n      tdir = new Vector3();\n    function handleTriangle(a, b, c) {\n      vA.fromArray(positions, a * 3);\n      vB.fromArray(positions, b * 3);\n      vC.fromArray(positions, c * 3);\n      uvA.fromArray(uvs, a * 2);\n      uvB.fromArray(uvs, b * 2);\n      uvC.fromArray(uvs, c * 2);\n      vB.sub(vA);\n      vC.sub(vA);\n      uvB.sub(uvA);\n      uvC.sub(uvA);\n      var r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y);\n\n      // silently ignore degenerate uv triangles having coincident or colinear vertices\n\n      if (!isFinite(r)) return;\n      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\n      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\n      tan1[a].add(sdir);\n      tan1[b].add(sdir);\n      tan1[c].add(sdir);\n      tan2[a].add(tdir);\n      tan2[b].add(tdir);\n      tan2[c].add(tdir);\n    }\n    var groups = geometry.groups;\n    if (groups.length === 0) {\n      groups = [{\n        start: 0,\n        count: indices.length\n      }];\n    }\n    for (var i = 0, il = groups.length; i < il; ++i) {\n      var group = groups[i];\n      var start = group.start;\n      var count = group.count;\n      for (var j = start, jl = start + count; j < jl; j += 3) {\n        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);\n      }\n    }\n    var tmp = new Vector3(),\n      tmp2 = new Vector3();\n    var n = new Vector3(),\n      n2 = new Vector3();\n    var w, t, test;\n    function handleVertex(v) {\n      n.fromArray(normals, v * 3);\n      n2.copy(n);\n      t = tan1[v];\n\n      // Gram-Schmidt orthogonalize\n\n      tmp.copy(t);\n      tmp.sub(n.multiplyScalar(n.dot(t))).normalize();\n\n      // Calculate handedness\n\n      tmp2.crossVectors(n2, t);\n      test = tmp2.dot(tan2[v]);\n      w = test < 0.0 ? -1.0 : 1.0;\n      tangents[v * 4] = tmp.x;\n      tangents[v * 4 + 1] = tmp.y;\n      tangents[v * 4 + 2] = tmp.z;\n      tangents[v * 4 + 3] = w;\n    }\n    for (var i = 0, il = groups.length; i < il; ++i) {\n      var group = groups[i];\n      var start = group.start;\n      var count = group.count;\n      for (var j = start, jl = start + count; j < jl; j += 3) {\n        handleVertex(indices[j + 0]);\n        handleVertex(indices[j + 1]);\n        handleVertex(indices[j + 2]);\n      }\n    }\n  },\n  /**\n   * @param  {Array<BufferGeometry>} geometries\n   * @param  {Boolean} useGroups\n   * @return {BufferGeometry}\n   */\n  mergeBufferGeometries: function mergeBufferGeometries(geometries, useGroups) {\n    var isIndexed = geometries[0].index !== null;\n    var attributesUsed = new Set(Object.keys(geometries[0].attributes));\n    var morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n    var attributes = {};\n    var morphAttributes = {};\n    var morphTargetsRelative = geometries[0].morphTargetsRelative;\n    var mergedGeometry = new BufferGeometry();\n    var offset = 0;\n    for (var i = 0; i < geometries.length; ++i) {\n      var geometry = geometries[i];\n      var attributesCount = 0;\n\n      // ensure that all geometries are indexed, or none\n\n      if (isIndexed !== (geometry.index !== null)) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n        return null;\n      }\n\n      // gather attributes, exit early if they're different\n\n      for (var name in geometry.attributes) {\n        if (!attributesUsed.has(name)) {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n          return null;\n        }\n        if (attributes[name] === undefined) attributes[name] = [];\n        attributes[name].push(geometry.attributes[name]);\n        attributesCount++;\n      }\n\n      // ensure geometries have the same number of attributes\n\n      if (attributesCount !== attributesUsed.size) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');\n        return null;\n      }\n\n      // gather morph attributes, exit early if they're different\n\n      if (morphTargetsRelative !== geometry.morphTargetsRelative) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');\n        return null;\n      }\n      for (var name in geometry.morphAttributes) {\n        if (!morphAttributesUsed.has(name)) {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');\n          return null;\n        }\n        if (morphAttributes[name] === undefined) morphAttributes[name] = [];\n        morphAttributes[name].push(geometry.morphAttributes[name]);\n      }\n\n      // gather .userData\n\n      mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n      mergedGeometry.userData.mergedUserData.push(geometry.userData);\n      if (useGroups) {\n        var count;\n        if (isIndexed) {\n          count = geometry.index.count;\n        } else if (geometry.attributes.position !== undefined) {\n          count = geometry.attributes.position.count;\n        } else {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');\n          return null;\n        }\n        mergedGeometry.addGroup(offset, count, i);\n        offset += count;\n      }\n    }\n\n    // merge indices\n\n    if (isIndexed) {\n      var indexOffset = 0;\n      var mergedIndex = [];\n      for (var i = 0; i < geometries.length; ++i) {\n        var index = geometries[i].index;\n        for (var j = 0; j < index.count; ++j) {\n          mergedIndex.push(index.getX(j) + indexOffset);\n        }\n        indexOffset += geometries[i].attributes.position.count;\n      }\n      mergedGeometry.setIndex(mergedIndex);\n    }\n\n    // merge attributes\n\n    for (var name in attributes) {\n      var mergedAttribute = this.mergeBufferAttributes(attributes[name]);\n      if (!mergedAttribute) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.');\n        return null;\n      }\n      mergedGeometry.setAttribute(name, mergedAttribute);\n    }\n\n    // merge morph attributes\n\n    for (var name in morphAttributes) {\n      var numMorphTargets = morphAttributes[name][0].length;\n      if (numMorphTargets === 0) break;\n      mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n      mergedGeometry.morphAttributes[name] = [];\n      for (var i = 0; i < numMorphTargets; ++i) {\n        var morphAttributesToMerge = [];\n        for (var j = 0; j < morphAttributes[name].length; ++j) {\n          morphAttributesToMerge.push(morphAttributes[name][j][i]);\n        }\n        var mergedMorphAttribute = this.mergeBufferAttributes(morphAttributesToMerge);\n        if (!mergedMorphAttribute) {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.');\n          return null;\n        }\n        mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n      }\n    }\n    return mergedGeometry;\n  },\n  /**\n   * @param {Array<BufferAttribute>} attributes\n   * @return {BufferAttribute}\n   */\n  mergeBufferAttributes: function mergeBufferAttributes(attributes) {\n    var TypedArray;\n    var itemSize;\n    var normalized;\n    var arrayLength = 0;\n    for (var i = 0; i < attributes.length; ++i) {\n      var attribute = attributes[i];\n      if (attribute.isInterleavedBufferAttribute) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.');\n        return null;\n      }\n      if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n      if (TypedArray !== attribute.array.constructor) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');\n        return null;\n      }\n      if (itemSize === undefined) itemSize = attribute.itemSize;\n      if (itemSize !== attribute.itemSize) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');\n        return null;\n      }\n      if (normalized === undefined) normalized = attribute.normalized;\n      if (normalized !== attribute.normalized) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');\n        return null;\n      }\n      arrayLength += attribute.array.length;\n    }\n    var array = new TypedArray(arrayLength);\n    var offset = 0;\n    for (var i = 0; i < attributes.length; ++i) {\n      array.set(attributes[i].array, offset);\n      offset += attributes[i].array.length;\n    }\n    return new BufferAttribute(array, itemSize, normalized);\n  },\n  /**\n   * @param {Array<BufferAttribute>} attributes\n   * @return {Array<InterleavedBufferAttribute>}\n   */\n  interleaveAttributes: function interleaveAttributes(attributes) {\n    // Interleaves the provided attributes into an InterleavedBuffer and returns\n    // a set of InterleavedBufferAttributes for each attribute\n    var TypedArray;\n    var arrayLength = 0;\n    var stride = 0;\n\n    // calculate the the length and type of the interleavedBuffer\n    for (var i = 0, l = attributes.length; i < l; ++i) {\n      var attribute = attributes[i];\n      if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n      if (TypedArray !== attribute.array.constructor) {\n        console.error('AttributeBuffers of different types cannot be interleaved');\n        return null;\n      }\n      arrayLength += attribute.array.length;\n      stride += attribute.itemSize;\n    }\n\n    // Create the set of buffer attributes\n    var interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n    var offset = 0;\n    var res = [];\n    var getters = ['getX', 'getY', 'getZ', 'getW'];\n    var setters = ['setX', 'setY', 'setZ', 'setW'];\n    for (var j = 0, l = attributes.length; j < l; j++) {\n      var attribute = attributes[j];\n      var itemSize = attribute.itemSize;\n      var count = attribute.count;\n      var iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n      res.push(iba);\n      offset += itemSize;\n\n      // Move the data for each attribute into the new interleavedBuffer\n      // at the appropriate offset\n      for (var c = 0; c < count; c++) {\n        for (var k = 0; k < itemSize; k++) {\n          iba[setters[k]](c, attribute[getters[k]](c));\n        }\n      }\n    }\n    return res;\n  },\n  /**\n   * @param {Array<BufferGeometry>} geometry\n   * @return {number}\n   */\n  estimateBytesUsed: function estimateBytesUsed(geometry) {\n    // Return the estimated memory used by this geometry in bytes\n    // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n    // for InterleavedBufferAttributes.\n    var mem = 0;\n    for (var name in geometry.attributes) {\n      var attr = geometry.getAttribute(name);\n      mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n    }\n    var indices = geometry.getIndex();\n    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n    return mem;\n  },\n  /**\n   * @param {BufferGeometry} geometry\n   * @param {number} tolerance\n   * @return {BufferGeometry>}\n   */\n  mergeVertices: function mergeVertices(geometry) {\n    var tolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-4;\n    tolerance = Math.max(tolerance, Number.EPSILON);\n\n    // Generate an index buffer if the geometry doesn't have one, or optimize it\n    // if it's already available.\n    var hashToIndex = {};\n    var indices = geometry.getIndex();\n    var positions = geometry.getAttribute('position');\n    var vertexCount = indices ? indices.count : positions.count;\n\n    // next value for triangle indices\n    var nextIndex = 0;\n\n    // attributes and new attribute arrays\n    var attributeNames = Object.keys(geometry.attributes);\n    var attrArrays = {};\n    var morphAttrsArrays = {};\n    var newIndices = [];\n    var getters = ['getX', 'getY', 'getZ', 'getW'];\n\n    // initialize the arrays\n    for (var i = 0, l = attributeNames.length; i < l; i++) {\n      var name = attributeNames[i];\n      attrArrays[name] = [];\n      var morphAttr = geometry.morphAttributes[name];\n      if (morphAttr) {\n        morphAttrsArrays[name] = new Array(morphAttr.length).fill().map(function () {\n          return [];\n        });\n      }\n    }\n\n    // convert the error tolerance to an amount of decimal places to truncate to\n    var decimalShift = Math.log10(1 / tolerance);\n    var shiftMultiplier = Math.pow(10, decimalShift);\n    for (var i = 0; i < vertexCount; i++) {\n      var index = indices ? indices.getX(i) : i;\n\n      // Generate a hash for the vertex attributes at the current index 'i'\n      var hash = '';\n      for (var j = 0, l = attributeNames.length; j < l; j++) {\n        var name = attributeNames[j];\n        var attribute = geometry.getAttribute(name);\n        var itemSize = attribute.itemSize;\n        for (var k = 0; k < itemSize; k++) {\n          // double tilde truncates the decimal value\n          hash += \"\".concat(~~(attribute[getters[k]](index) * shiftMultiplier), \",\");\n        }\n      }\n\n      // Add another reference to the vertex if it's already\n      // used by another index\n      if (hash in hashToIndex) {\n        newIndices.push(hashToIndex[hash]);\n      } else {\n        // copy data to the new index in the attribute arrays\n        for (var j = 0, l = attributeNames.length; j < l; j++) {\n          var name = attributeNames[j];\n          var attribute = geometry.getAttribute(name);\n          var morphAttr = geometry.morphAttributes[name];\n          var itemSize = attribute.itemSize;\n          var newarray = attrArrays[name];\n          var newMorphArrays = morphAttrsArrays[name];\n          for (var k = 0; k < itemSize; k++) {\n            var getterFunc = getters[k];\n            newarray.push(attribute[getterFunc](index));\n            if (morphAttr) {\n              for (var m = 0, ml = morphAttr.length; m < ml; m++) {\n                newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n              }\n            }\n          }\n        }\n        hashToIndex[hash] = nextIndex;\n        newIndices.push(nextIndex);\n        nextIndex++;\n      }\n    }\n\n    // Generate typed arrays from new attribute arrays and update\n    // the attributeBuffers\n    var result = geometry.clone();\n    for (var i = 0, l = attributeNames.length; i < l; i++) {\n      var name = attributeNames[i];\n      var oldAttribute = geometry.getAttribute(name);\n      var buffer = new oldAttribute.array.constructor(attrArrays[name]);\n      var attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n      result.setAttribute(name, attribute);\n\n      // Update the attribute arrays\n      if (name in morphAttrsArrays) {\n        for (var j = 0; j < morphAttrsArrays[name].length; j++) {\n          var oldMorphAttribute = geometry.morphAttributes[name][j];\n          var buffer = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n          var morphAttribute = new BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n          result.morphAttributes[name][j] = morphAttribute;\n        }\n      }\n    }\n\n    // indices\n\n    result.setIndex(newIndices);\n    return result;\n  },\n  /**\n   * @param {BufferGeometry} geometry\n   * @param {number} drawMode\n   * @return {BufferGeometry>}\n   */\n  toTrianglesDrawMode: function toTrianglesDrawMode(geometry, drawMode) {\n    if (drawMode === TrianglesDrawMode) {\n      console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');\n      return geometry;\n    }\n    if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n      var index = geometry.getIndex();\n\n      // generate index if not present\n\n      if (index === null) {\n        var indices = [];\n        var position = geometry.getAttribute('position');\n        if (position !== undefined) {\n          for (var i = 0; i < position.count; i++) {\n            indices.push(i);\n          }\n          geometry.setIndex(indices);\n          index = geometry.getIndex();\n        } else {\n          console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n          return geometry;\n        }\n      }\n\n      //\n\n      var numberOfTriangles = index.count - 2;\n      var newIndices = [];\n      if (drawMode === TriangleFanDrawMode) {\n        // gl.TRIANGLE_FAN\n\n        for (var i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        // gl.TRIANGLE_STRIP\n\n        for (var i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n      if (newIndices.length / 3 !== numberOfTriangles) {\n        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n      }\n\n      // build final geometry\n\n      var newGeometry = geometry.clone();\n      newGeometry.setIndex(newIndices);\n      newGeometry.clearGroups();\n      return newGeometry;\n    } else {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);\n      return geometry;\n    }\n  }\n};\nexport { BufferGeometryUtils };","map":{"version":3,"names":["BufferAttribute","BufferGeometry","InterleavedBuffer","InterleavedBufferAttribute","TriangleFanDrawMode","TriangleStripDrawMode","TrianglesDrawMode","Vector2","Vector3","BufferGeometryUtils","computeTangents","geometry","index","attributes","position","undefined","normal","uv","console","error","indices","array","positions","normals","uvs","nVertices","length","tangent","setAttribute","Float32Array","tangents","tan1","tan2","i","vA","vB","vC","uvA","uvB","uvC","sdir","tdir","handleTriangle","a","b","c","fromArray","sub","r","x","y","isFinite","copy","multiplyScalar","addScaledVector","add","groups","start","count","il","group","j","jl","tmp","tmp2","n","n2","w","t","test","handleVertex","v","dot","normalize","crossVectors","z","mergeBufferGeometries","geometries","useGroups","isIndexed","attributesUsed","Set","Object","keys","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","offset","attributesCount","name","has","push","size","userData","mergedUserData","addGroup","indexOffset","mergedIndex","getX","setIndex","mergedAttribute","mergeBufferAttributes","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","TypedArray","itemSize","normalized","arrayLength","attribute","isInterleavedBufferAttribute","constructor","set","interleaveAttributes","stride","l","interleavedBuffer","res","getters","setters","iba","k","estimateBytesUsed","mem","attr","getAttribute","BYTES_PER_ELEMENT","getIndex","mergeVertices","tolerance","arguments","Math","max","Number","EPSILON","hashToIndex","vertexCount","nextIndex","attributeNames","attrArrays","morphAttrsArrays","newIndices","morphAttr","Array","fill","map","decimalShift","log10","shiftMultiplier","pow","hash","concat","newarray","newMorphArrays","getterFunc","m","ml","result","clone","oldAttribute","buffer","oldMorphAttribute","morphAttribute","toTrianglesDrawMode","drawMode","warn","numberOfTriangles","newGeometry","clearGroups"],"sources":["/Users/Aaron/Desktop/mirrorsReactThreeFiber/node_modules/three/examples/jsm/utils/BufferGeometryUtils.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector2,\n\tVector3\n} from \"../../../build/three.module.js\";\n\nvar BufferGeometryUtils = {\n\n\tcomputeTangents: function ( geometry ) {\n\n\t\tvar index = geometry.index;\n\t\tvar attributes = geometry.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar indices = index.array;\n\t\tvar positions = attributes.position.array;\n\t\tvar normals = attributes.normal.array;\n\t\tvar uvs = attributes.uv.array;\n\n\t\tvar nVertices = positions.length / 3;\n\n\t\tif ( attributes.tangent === undefined ) {\n\n\t\t\tgeometry.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );\n\n\t\t}\n\n\t\tvar tangents = attributes.tangent.array;\n\n\t\tvar tan1 = [], tan2 = [];\n\n\t\tfor ( var i = 0; i < nVertices; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tvar vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\tvC.fromArray( positions, c * 3 );\n\n\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\tuvC.fromArray( uvs, c * 2 );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tvar r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tvar groups = geometry.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: indices.length\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( var i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tvar group = groups[ i ];\n\n\t\t\tvar start = group.start;\n\t\t\tvar count = group.count;\n\n\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindices[ j + 0 ],\n\t\t\t\t\tindices[ j + 1 ],\n\t\t\t\t\tindices[ j + 2 ]\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar tmp = new Vector3(), tmp2 = new Vector3();\n\t\tvar n = new Vector3(), n2 = new Vector3();\n\t\tvar w, t, test;\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromArray( normals, v * 3 );\n\t\t\tn2.copy( n );\n\n\t\t\tt = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\ttest = tmp2.dot( tan2[ v ] );\n\t\t\tw = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangents[ v * 4 ] = tmp.x;\n\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\n\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\n\t\t\ttangents[ v * 4 + 3 ] = w;\n\n\t\t}\n\n\t\tfor ( var i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tvar group = groups[ i ];\n\n\t\t\tvar start = group.start;\n\t\t\tvar count = group.count;\n\n\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( indices[ j + 0 ] );\n\t\t\t\thandleVertex( indices[ j + 1 ] );\n\t\t\t\thandleVertex( indices[ j + 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t/**\n\t * @param  {Array<BufferGeometry>} geometries\n\t * @param  {Boolean} useGroups\n\t * @return {BufferGeometry}\n\t */\n\tmergeBufferGeometries: function ( geometries, useGroups ) {\n\n\t\tvar isIndexed = geometries[ 0 ].index !== null;\n\n\t\tvar attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\t\tvar morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\t\tvar attributes = {};\n\t\tvar morphAttributes = {};\n\n\t\tvar morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\t\tvar mergedGeometry = new BufferGeometry();\n\n\t\tvar offset = 0;\n\n\t\tfor ( var i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tvar geometry = geometries[ i ];\n\t\t\tvar attributesCount = 0;\n\n\t\t\t// ensure that all geometries are indexed, or none\n\n\t\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// gather attributes, exit early if they're different\n\n\t\t\tfor ( var name in geometry.attributes ) {\n\n\t\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\t\tattributesCount ++;\n\n\t\t\t}\n\n\t\t\t// ensure geometries have the same number of attributes\n\n\t\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// gather morph attributes, exit early if they're different\n\n\t\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tfor ( var name in geometry.morphAttributes ) {\n\n\t\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t\t}\n\n\t\t\t// gather .userData\n\n\t\t\tmergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n\t\t\tmergedGeometry.userData.mergedUserData.push( geometry.userData );\n\n\t\t\tif ( useGroups ) {\n\n\t\t\t\tvar count;\n\n\t\t\t\tif ( isIndexed ) {\n\n\t\t\t\t\tcount = geometry.index.count;\n\n\t\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\t\toffset += count;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// merge indices\n\n\t\tif ( isIndexed ) {\n\n\t\t\tvar indexOffset = 0;\n\t\t\tvar mergedIndex = [];\n\n\t\t\tfor ( var i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tvar index = geometries[ i ].index;\n\n\t\t\t\tfor ( var j = 0; j < index.count; ++ j ) {\n\n\t\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t\t}\n\n\t\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t\t}\n\n\t\t// merge attributes\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar mergedAttribute = this.mergeBufferAttributes( attributes[ name ] );\n\n\t\t\tif ( ! mergedAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t\t}\n\n\t\t// merge morph attributes\n\n\t\tfor ( var name in morphAttributes ) {\n\n\t\t\tvar numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\t\tif ( numMorphTargets === 0 ) break;\n\n\t\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\t\tfor ( var i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\t\tvar morphAttributesToMerge = [];\n\n\t\t\t\tfor ( var j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tvar mergedMorphAttribute = this.mergeBufferAttributes( morphAttributesToMerge );\n\n\t\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn mergedGeometry;\n\n\t},\n\n\t/**\n\t * @param {Array<BufferAttribute>} attributes\n\t * @return {BufferAttribute}\n\t */\n\tmergeBufferAttributes: function ( attributes ) {\n\n\t\tvar TypedArray;\n\t\tvar itemSize;\n\t\tvar normalized;\n\t\tvar arrayLength = 0;\n\n\t\tfor ( var i = 0; i < attributes.length; ++ i ) {\n\n\t\t\tvar attribute = attributes[ i ];\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tarrayLength += attribute.array.length;\n\n\t\t}\n\n\t\tvar array = new TypedArray( arrayLength );\n\t\tvar offset = 0;\n\n\t\tfor ( var i = 0; i < attributes.length; ++ i ) {\n\n\t\t\tarray.set( attributes[ i ].array, offset );\n\n\t\t\toffset += attributes[ i ].array.length;\n\n\t\t}\n\n\t\treturn new BufferAttribute( array, itemSize, normalized );\n\n\t},\n\n\t/**\n\t * @param {Array<BufferAttribute>} attributes\n\t * @return {Array<InterleavedBufferAttribute>}\n\t */\n\tinterleaveAttributes: function ( attributes ) {\n\n\t\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t\t// a set of InterleavedBufferAttributes for each attribute\n\t\tvar TypedArray;\n\t\tvar arrayLength = 0;\n\t\tvar stride = 0;\n\n\t\t// calculate the the length and type of the interleavedBuffer\n\t\tfor ( var i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\t\tvar attribute = attributes[ i ];\n\n\t\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tarrayLength += attribute.array.length;\n\t\t\tstride += attribute.itemSize;\n\n\t\t}\n\n\t\t// Create the set of buffer attributes\n\t\tvar interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\t\tvar offset = 0;\n\t\tvar res = [];\n\t\tvar getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\t\tvar setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t\tfor ( var j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\t\tvar attribute = attributes[ j ];\n\t\t\tvar itemSize = attribute.itemSize;\n\t\t\tvar count = attribute.count;\n\t\t\tvar iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\t\tres.push( iba );\n\n\t\t\toffset += itemSize;\n\n\t\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t\t// at the appropriate offset\n\t\t\tfor ( var c = 0; c < count; c ++ ) {\n\n\t\t\t\tfor ( var k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn res;\n\n\t},\n\n\t/**\n\t * @param {Array<BufferGeometry>} geometry\n\t * @return {number}\n\t */\n\testimateBytesUsed: function ( geometry ) {\n\n\t\t// Return the estimated memory used by this geometry in bytes\n\t\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t\t// for InterleavedBufferAttributes.\n\t\tvar mem = 0;\n\t\tfor ( var name in geometry.attributes ) {\n\n\t\t\tvar attr = geometry.getAttribute( name );\n\t\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t\t}\n\n\t\tvar indices = geometry.getIndex();\n\t\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\t\treturn mem;\n\n\t},\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {number} tolerance\n\t * @return {BufferGeometry>}\n\t */\n\tmergeVertices: function ( geometry, tolerance = 1e-4 ) {\n\n\t\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t\t// if it's already available.\n\t\tvar hashToIndex = {};\n\t\tvar indices = geometry.getIndex();\n\t\tvar positions = geometry.getAttribute( 'position' );\n\t\tvar vertexCount = indices ? indices.count : positions.count;\n\n\t\t// next value for triangle indices\n\t\tvar nextIndex = 0;\n\n\t\t// attributes and new attribute arrays\n\t\tvar attributeNames = Object.keys( geometry.attributes );\n\t\tvar attrArrays = {};\n\t\tvar morphAttrsArrays = {};\n\t\tvar newIndices = [];\n\t\tvar getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\n\t\t// initialize the arrays\n\t\tfor ( var i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\t\tvar name = attributeNames[ i ];\n\n\t\t\tattrArrays[ name ] = [];\n\n\t\t\tvar morphAttr = geometry.morphAttributes[ name ];\n\t\t\tif ( morphAttr ) {\n\n\t\t\t\tmorphAttrsArrays[ name ] = new Array( morphAttr.length ).fill().map( () => [] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// convert the error tolerance to an amount of decimal places to truncate to\n\t\tvar decimalShift = Math.log10( 1 / tolerance );\n\t\tvar shiftMultiplier = Math.pow( 10, decimalShift );\n\t\tfor ( var i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tvar index = indices ? indices.getX( i ) : i;\n\n\t\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\t\tvar hash = '';\n\t\t\tfor ( var j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tvar name = attributeNames[ j ];\n\t\t\t\tvar attribute = geometry.getAttribute( name );\n\t\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\t\tfor ( var k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Add another reference to the vertex if it's already\n\t\t\t// used by another index\n\t\t\tif ( hash in hashToIndex ) {\n\n\t\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t\t} else {\n\n\t\t\t\t// copy data to the new index in the attribute arrays\n\t\t\t\tfor ( var j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\t\tvar name = attributeNames[ j ];\n\t\t\t\t\tvar attribute = geometry.getAttribute( name );\n\t\t\t\t\tvar morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\t\tvar itemSize = attribute.itemSize;\n\t\t\t\t\tvar newarray = attrArrays[ name ];\n\t\t\t\t\tvar newMorphArrays = morphAttrsArrays[ name ];\n\n\t\t\t\t\tfor ( var k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\t\tvar getterFunc = getters[ k ];\n\t\t\t\t\t\tnewarray.push( attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\t\tfor ( var m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\t\tnewMorphArrays[ m ].push( morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\t\tnewIndices.push( nextIndex );\n\t\t\t\tnextIndex ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Generate typed arrays from new attribute arrays and update\n\t\t// the attributeBuffers\n\t\tconst result = geometry.clone();\n\t\tfor ( var i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\t\tvar name = attributeNames[ i ];\n\t\t\tvar oldAttribute = geometry.getAttribute( name );\n\n\t\t\tvar buffer = new oldAttribute.array.constructor( attrArrays[ name ] );\n\t\t\tvar attribute = new BufferAttribute( buffer, oldAttribute.itemSize, oldAttribute.normalized );\n\n\t\t\tresult.setAttribute( name, attribute );\n\n\t\t\t// Update the attribute arrays\n\t\t\tif ( name in morphAttrsArrays ) {\n\n\t\t\t\tfor ( var j = 0; j < morphAttrsArrays[ name ].length; j ++ ) {\n\n\t\t\t\t\tvar oldMorphAttribute = geometry.morphAttributes[ name ][ j ];\n\n\t\t\t\t\tvar buffer = new oldMorphAttribute.array.constructor( morphAttrsArrays[ name ][ j ] );\n\t\t\t\t\tvar morphAttribute = new BufferAttribute( buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized );\n\t\t\t\t\tresult.morphAttributes[ name ][ j ] = morphAttribute;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\tresult.setIndex( newIndices );\n\n\t\treturn result;\n\n\t},\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {number} drawMode\n\t * @return {BufferGeometry>}\n\t */\n\ttoTrianglesDrawMode: function ( geometry, drawMode ) {\n\n\t\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\t\tvar index = geometry.getIndex();\n\n\t\t\t// generate index if not present\n\n\t\t\tif ( index === null ) {\n\n\t\t\t\tvar indices = [];\n\n\t\t\t\tvar position = geometry.getAttribute( 'position' );\n\n\t\t\t\tif ( position !== undefined ) {\n\n\t\t\t\t\tfor ( var i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\t\tindices.push( i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\t\treturn geometry;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar numberOfTriangles = index.count - 2;\n\t\t\tvar newIndices = [];\n\n\t\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\t\tfor ( var i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\t\tfor ( var i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t\t}\n\n\t\t\t// build final geometry\n\n\t\t\tvar newGeometry = geometry.clone();\n\t\t\tnewGeometry.setIndex( newIndices );\n\t\t\tnewGeometry.clearGroups();\n\n\t\t\treturn newGeometry;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t}\n\n};\n\nexport { BufferGeometryUtils };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}