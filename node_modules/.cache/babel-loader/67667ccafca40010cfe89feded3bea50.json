{"ast":null,"code":"import { Color, LinearFilter, MathUtils, Matrix4, Mesh, PerspectiveCamera, Plane, RGBFormat, ShaderMaterial, UniformsUtils, Vector3, Vector4, WebGLRenderTarget } from \"../../../build/three.module.js\";\nvar Reflector = function Reflector(geometry, options) {\n  Mesh.call(this, geometry);\n  this.type = 'Reflector';\n  var scope = this;\n  options = options || {};\n  var color = options.color !== undefined ? new Color(options.color) : new Color(0x7F7F7F);\n  var textureWidth = options.textureWidth || 512;\n  var textureHeight = options.textureHeight || 512;\n  var clipBias = options.clipBias || 0;\n  var shader = options.shader || Reflector.ReflectorShader;\n\n  //\n\n  var reflectorPlane = new Plane();\n  var normal = new Vector3();\n  var reflectorWorldPosition = new Vector3();\n  var cameraWorldPosition = new Vector3();\n  var rotationMatrix = new Matrix4();\n  var lookAtPosition = new Vector3(0, 0, -1);\n  var clipPlane = new Vector4();\n  var view = new Vector3();\n  var target = new Vector3();\n  var q = new Vector4();\n  var textureMatrix = new Matrix4();\n  var virtualCamera = new PerspectiveCamera();\n  var parameters = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBFormat\n  };\n  var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n  if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n    renderTarget.texture.generateMipmaps = false;\n  }\n  var material = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(shader.uniforms),\n    fragmentShader: shader.fragmentShader,\n    vertexShader: shader.vertexShader\n  });\n  material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n  material.uniforms[\"color\"].value = color;\n  material.uniforms[\"textureMatrix\"].value = textureMatrix;\n  this.material = material;\n  this.onBeforeRender = function (renderer, scene, camera) {\n    reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    rotationMatrix.extractRotation(scope.matrixWorld);\n    normal.set(0, 0, 1);\n    normal.applyMatrix4(rotationMatrix);\n    view.subVectors(reflectorWorldPosition, cameraWorldPosition);\n\n    // Avoid rendering when reflector is facing away\n\n    if (view.dot(normal) > 0) return;\n    view.reflect(normal).negate();\n    view.add(reflectorWorldPosition);\n    rotationMatrix.extractRotation(camera.matrixWorld);\n    lookAtPosition.set(0, 0, -1);\n    lookAtPosition.applyMatrix4(rotationMatrix);\n    lookAtPosition.add(cameraWorldPosition);\n    target.subVectors(reflectorWorldPosition, lookAtPosition);\n    target.reflect(normal).negate();\n    target.add(reflectorWorldPosition);\n    virtualCamera.position.copy(view);\n    virtualCamera.up.set(0, 1, 0);\n    virtualCamera.up.applyMatrix4(rotationMatrix);\n    virtualCamera.up.reflect(normal);\n    virtualCamera.lookAt(target);\n    virtualCamera.far = camera.far; // Used in WebGLBackground\n\n    virtualCamera.updateMatrixWorld();\n    virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n\n    // Update the texture matrix\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(virtualCamera.projectionMatrix);\n    textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n    textureMatrix.multiply(scope.matrixWorld);\n\n    // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n    reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n    reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n    clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n    var projectionMatrix = virtualCamera.projectionMatrix;\n    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    q.z = -1.0;\n    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n\n    // Calculate the scaled plane vector\n    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q));\n\n    // Replacing the third row of the projection matrix\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w;\n\n    // Render\n\n    renderTarget.texture.encoding = renderer.outputEncoding;\n    scope.visible = false;\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentXrEnabled = renderer.xr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    renderer.xr.enabled = false; // Avoid camera modification\n    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n    renderer.setRenderTarget(renderTarget);\n    renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n    if (renderer.autoClear === false) renderer.clear();\n    renderer.render(scene, virtualCamera);\n    renderer.xr.enabled = currentXrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.setRenderTarget(currentRenderTarget);\n\n    // Restore viewport\n\n    var viewport = camera.viewport;\n    if (viewport !== undefined) {\n      renderer.state.viewport(viewport);\n    }\n    scope.visible = true;\n  };\n  this.getRenderTarget = function () {\n    return renderTarget;\n  };\n};\nReflector.prototype = Object.create(Mesh.prototype);\nReflector.prototype.constructor = Reflector;\nReflector.ReflectorShader = {\n  uniforms: {\n    'color': {\n      value: null\n    },\n    'tDiffuse': {\n      value: null\n    },\n    'textureMatrix': {\n      value: null\n    }\n  },\n  vertexShader: ['uniform mat4 textureMatrix;', 'varying vec4 vUv;', 'void main() {', '\tvUv = textureMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform vec3 color;', 'uniform sampler2D tDiffuse;', 'varying vec4 vUv;', 'float blendOverlay( float base, float blend ) {', '\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );', '}', 'vec3 blendOverlay( vec3 base, vec3 blend ) {', '\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );', '}', 'void main() {', '\tvec4 base = texture2DProj( tDiffuse, vUv );', '\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );', '}'].join('\\n')\n};\nexport { Reflector };","map":{"version":3,"names":["Color","LinearFilter","MathUtils","Matrix4","Mesh","PerspectiveCamera","Plane","RGBFormat","ShaderMaterial","UniformsUtils","Vector3","Vector4","WebGLRenderTarget","Reflector","geometry","options","call","type","scope","color","undefined","textureWidth","textureHeight","clipBias","shader","ReflectorShader","reflectorPlane","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","virtualCamera","parameters","minFilter","magFilter","format","renderTarget","isPowerOfTwo","texture","generateMipmaps","material","uniforms","clone","fragmentShader","vertexShader","value","onBeforeRender","renderer","scene","camera","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","encoding","outputEncoding","visible","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","prototype","Object","create","constructor","join"],"sources":["/Users/Aaron/Desktop/mirrorsReactThreeFiber/node_modules/three/examples/jsm/objects/Reflector.js"],"sourcesContent":["import {\n\tColor,\n\tLinearFilter,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tPerspectiveCamera,\n\tPlane,\n\tRGBFormat,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector3,\n\tVector4,\n\tWebGLRenderTarget\n} from \"../../../build/three.module.js\";\n\nvar Reflector = function ( geometry, options ) {\n\n\tMesh.call( this, geometry );\n\n\tthis.type = 'Reflector';\n\n\tvar scope = this;\n\n\toptions = options || {};\n\n\tvar color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );\n\tvar textureWidth = options.textureWidth || 512;\n\tvar textureHeight = options.textureHeight || 512;\n\tvar clipBias = options.clipBias || 0;\n\tvar shader = options.shader || Reflector.ReflectorShader;\n\n\t//\n\n\tvar reflectorPlane = new Plane();\n\tvar normal = new Vector3();\n\tvar reflectorWorldPosition = new Vector3();\n\tvar cameraWorldPosition = new Vector3();\n\tvar rotationMatrix = new Matrix4();\n\tvar lookAtPosition = new Vector3( 0, 0, - 1 );\n\tvar clipPlane = new Vector4();\n\n\tvar view = new Vector3();\n\tvar target = new Vector3();\n\tvar q = new Vector4();\n\n\tvar textureMatrix = new Matrix4();\n\tvar virtualCamera = new PerspectiveCamera();\n\n\tvar parameters = {\n\t\tminFilter: LinearFilter,\n\t\tmagFilter: LinearFilter,\n\t\tformat: RGBFormat\n\t};\n\n\tvar renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, parameters );\n\n\tif ( ! MathUtils.isPowerOfTwo( textureWidth ) || ! MathUtils.isPowerOfTwo( textureHeight ) ) {\n\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t}\n\n\tvar material = new ShaderMaterial( {\n\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\tfragmentShader: shader.fragmentShader,\n\t\tvertexShader: shader.vertexShader\n\t} );\n\n\tmaterial.uniforms[ \"tDiffuse\" ].value = renderTarget.texture;\n\tmaterial.uniforms[ \"color\" ].value = color;\n\tmaterial.uniforms[ \"textureMatrix\" ].value = textureMatrix;\n\n\tthis.material = material;\n\n\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\treflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\tnormal.set( 0, 0, 1 );\n\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\tview.subVectors( reflectorWorldPosition, cameraWorldPosition );\n\n\t\t// Avoid rendering when reflector is facing away\n\n\t\tif ( view.dot( normal ) > 0 ) return;\n\n\t\tview.reflect( normal ).negate();\n\t\tview.add( reflectorWorldPosition );\n\n\t\trotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\tlookAtPosition.set( 0, 0, - 1 );\n\t\tlookAtPosition.applyMatrix4( rotationMatrix );\n\t\tlookAtPosition.add( cameraWorldPosition );\n\n\t\ttarget.subVectors( reflectorWorldPosition, lookAtPosition );\n\t\ttarget.reflect( normal ).negate();\n\t\ttarget.add( reflectorWorldPosition );\n\n\t\tvirtualCamera.position.copy( view );\n\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\tvirtualCamera.up.applyMatrix4( rotationMatrix );\n\t\tvirtualCamera.up.reflect( normal );\n\t\tvirtualCamera.lookAt( target );\n\n\t\tvirtualCamera.far = camera.far; // Used in WebGLBackground\n\n\t\tvirtualCamera.updateMatrixWorld();\n\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t// Update the texture matrix\n\t\ttextureMatrix.set(\n\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\t\ttextureMatrix.multiply( virtualCamera.projectionMatrix );\n\t\ttextureMatrix.multiply( virtualCamera.matrixWorldInverse );\n\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\treflectorPlane.setFromNormalAndCoplanarPoint( normal, reflectorWorldPosition );\n\t\treflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\tclipPlane.set( reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant );\n\n\t\tvar projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\tq.z = - 1.0;\n\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t// Calculate the scaled plane vector\n\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\n\n\t\t// Replacing the third row of the projection matrix\n\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\n\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t// Render\n\n\t\trenderTarget.texture.encoding = renderer.outputEncoding;\n\n\t\tscope.visible = false;\n\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\tvar currentXrEnabled = renderer.xr.enabled;\n\t\tvar currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\trenderer.xr.enabled = false; // Avoid camera modification\n\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n\t\trenderer.setRenderTarget( renderTarget );\n\n\t\trenderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\trenderer.render( scene, virtualCamera );\n\n\t\trenderer.xr.enabled = currentXrEnabled;\n\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t// Restore viewport\n\n\t\tvar viewport = camera.viewport;\n\n\t\tif ( viewport !== undefined ) {\n\n\t\t\trenderer.state.viewport( viewport );\n\n\t\t}\n\n\t\tscope.visible = true;\n\n\t};\n\n\tthis.getRenderTarget = function () {\n\n\t\treturn renderTarget;\n\n\t};\n\n};\n\nReflector.prototype = Object.create( Mesh.prototype );\nReflector.prototype.constructor = Reflector;\n\nReflector.ReflectorShader = {\n\n\tuniforms: {\n\n\t\t'color': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tDiffuse': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'textureMatrix': {\n\t\t\tvalue: null\n\t\t}\n\n\t},\n\n\tvertexShader: [\n\t\t'uniform mat4 textureMatrix;',\n\t\t'varying vec4 vUv;',\n\n\t\t'void main() {',\n\n\t\t'\tvUv = textureMatrix * vec4( position, 1.0 );',\n\n\t\t'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n\t\t'}'\n\t].join( '\\n' ),\n\n\tfragmentShader: [\n\t\t'uniform vec3 color;',\n\t\t'uniform sampler2D tDiffuse;',\n\t\t'varying vec4 vUv;',\n\n\t\t'float blendOverlay( float base, float blend ) {',\n\n\t\t'\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',\n\n\t\t'}',\n\n\t\t'vec3 blendOverlay( vec3 base, vec3 blend ) {',\n\n\t\t'\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );',\n\n\t\t'}',\n\n\t\t'void main() {',\n\n\t\t'\tvec4 base = texture2DProj( tDiffuse, vUv );',\n\t\t'\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',\n\n\t\t'}'\n\t].join( '\\n' )\n};\n\nexport { Reflector };\n"],"mappings":"AAAA,SACCA,KAAK,EACLC,YAAY,EACZC,SAAS,EACTC,OAAO,EACPC,IAAI,EACJC,iBAAiB,EACjBC,KAAK,EACLC,SAAS,EACTC,cAAc,EACdC,aAAa,EACbC,OAAO,EACPC,OAAO,EACPC,iBAAiB,QACX,gCAAgC;AAEvC,IAAIC,SAAS,GAAG,SAAZA,SAASA,CAAcC,QAAQ,EAAEC,OAAO,EAAG;EAE9CX,IAAI,CAACY,IAAI,CAAE,IAAI,EAAEF,QAAS,CAAC;EAE3B,IAAI,CAACG,IAAI,GAAG,WAAW;EAEvB,IAAIC,KAAK,GAAG,IAAI;EAEhBH,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EAEvB,IAAII,KAAK,GAAKJ,OAAO,CAACI,KAAK,KAAKC,SAAS,GAAK,IAAIpB,KAAK,CAAEe,OAAO,CAACI,KAAM,CAAC,GAAG,IAAInB,KAAK,CAAE,QAAS,CAAC;EAChG,IAAIqB,YAAY,GAAGN,OAAO,CAACM,YAAY,IAAI,GAAG;EAC9C,IAAIC,aAAa,GAAGP,OAAO,CAACO,aAAa,IAAI,GAAG;EAChD,IAAIC,QAAQ,GAAGR,OAAO,CAACQ,QAAQ,IAAI,CAAC;EACpC,IAAIC,MAAM,GAAGT,OAAO,CAACS,MAAM,IAAIX,SAAS,CAACY,eAAe;;EAExD;;EAEA,IAAIC,cAAc,GAAG,IAAIpB,KAAK,CAAC,CAAC;EAChC,IAAIqB,MAAM,GAAG,IAAIjB,OAAO,CAAC,CAAC;EAC1B,IAAIkB,sBAAsB,GAAG,IAAIlB,OAAO,CAAC,CAAC;EAC1C,IAAImB,mBAAmB,GAAG,IAAInB,OAAO,CAAC,CAAC;EACvC,IAAIoB,cAAc,GAAG,IAAI3B,OAAO,CAAC,CAAC;EAClC,IAAI4B,cAAc,GAAG,IAAIrB,OAAO,CAAE,CAAC,EAAE,CAAC,EAAE,CAAE,CAAE,CAAC;EAC7C,IAAIsB,SAAS,GAAG,IAAIrB,OAAO,CAAC,CAAC;EAE7B,IAAIsB,IAAI,GAAG,IAAIvB,OAAO,CAAC,CAAC;EACxB,IAAIwB,MAAM,GAAG,IAAIxB,OAAO,CAAC,CAAC;EAC1B,IAAIyB,CAAC,GAAG,IAAIxB,OAAO,CAAC,CAAC;EAErB,IAAIyB,aAAa,GAAG,IAAIjC,OAAO,CAAC,CAAC;EACjC,IAAIkC,aAAa,GAAG,IAAIhC,iBAAiB,CAAC,CAAC;EAE3C,IAAIiC,UAAU,GAAG;IAChBC,SAAS,EAAEtC,YAAY;IACvBuC,SAAS,EAAEvC,YAAY;IACvBwC,MAAM,EAAElC;EACT,CAAC;EAED,IAAImC,YAAY,GAAG,IAAI9B,iBAAiB,CAAES,YAAY,EAAEC,aAAa,EAAEgB,UAAW,CAAC;EAEnF,IAAK,CAAEpC,SAAS,CAACyC,YAAY,CAAEtB,YAAa,CAAC,IAAI,CAAEnB,SAAS,CAACyC,YAAY,CAAErB,aAAc,CAAC,EAAG;IAE5FoB,YAAY,CAACE,OAAO,CAACC,eAAe,GAAG,KAAK;EAE7C;EAEA,IAAIC,QAAQ,GAAG,IAAItC,cAAc,CAAE;IAClCuC,QAAQ,EAAEtC,aAAa,CAACuC,KAAK,CAAExB,MAAM,CAACuB,QAAS,CAAC;IAChDE,cAAc,EAAEzB,MAAM,CAACyB,cAAc;IACrCC,YAAY,EAAE1B,MAAM,CAAC0B;EACtB,CAAE,CAAC;EAEHJ,QAAQ,CAACC,QAAQ,CAAE,UAAU,CAAE,CAACI,KAAK,GAAGT,YAAY,CAACE,OAAO;EAC5DE,QAAQ,CAACC,QAAQ,CAAE,OAAO,CAAE,CAACI,KAAK,GAAGhC,KAAK;EAC1C2B,QAAQ,CAACC,QAAQ,CAAE,eAAe,CAAE,CAACI,KAAK,GAAGf,aAAa;EAE1D,IAAI,CAACU,QAAQ,GAAGA,QAAQ;EAExB,IAAI,CAACM,cAAc,GAAG,UAAWC,QAAQ,EAAEC,KAAK,EAAEC,MAAM,EAAG;IAE1D3B,sBAAsB,CAAC4B,qBAAqB,CAAEtC,KAAK,CAACuC,WAAY,CAAC;IACjE5B,mBAAmB,CAAC2B,qBAAqB,CAAED,MAAM,CAACE,WAAY,CAAC;IAE/D3B,cAAc,CAAC4B,eAAe,CAAExC,KAAK,CAACuC,WAAY,CAAC;IAEnD9B,MAAM,CAACgC,GAAG,CAAE,CAAC,EAAE,CAAC,EAAE,CAAE,CAAC;IACrBhC,MAAM,CAACiC,YAAY,CAAE9B,cAAe,CAAC;IAErCG,IAAI,CAAC4B,UAAU,CAAEjC,sBAAsB,EAAEC,mBAAoB,CAAC;;IAE9D;;IAEA,IAAKI,IAAI,CAAC6B,GAAG,CAAEnC,MAAO,CAAC,GAAG,CAAC,EAAG;IAE9BM,IAAI,CAAC8B,OAAO,CAAEpC,MAAO,CAAC,CAACqC,MAAM,CAAC,CAAC;IAC/B/B,IAAI,CAACgC,GAAG,CAAErC,sBAAuB,CAAC;IAElCE,cAAc,CAAC4B,eAAe,CAAEH,MAAM,CAACE,WAAY,CAAC;IAEpD1B,cAAc,CAAC4B,GAAG,CAAE,CAAC,EAAE,CAAC,EAAE,CAAE,CAAE,CAAC;IAC/B5B,cAAc,CAAC6B,YAAY,CAAE9B,cAAe,CAAC;IAC7CC,cAAc,CAACkC,GAAG,CAAEpC,mBAAoB,CAAC;IAEzCK,MAAM,CAAC2B,UAAU,CAAEjC,sBAAsB,EAAEG,cAAe,CAAC;IAC3DG,MAAM,CAAC6B,OAAO,CAAEpC,MAAO,CAAC,CAACqC,MAAM,CAAC,CAAC;IACjC9B,MAAM,CAAC+B,GAAG,CAAErC,sBAAuB,CAAC;IAEpCS,aAAa,CAAC6B,QAAQ,CAACC,IAAI,CAAElC,IAAK,CAAC;IACnCI,aAAa,CAAC+B,EAAE,CAACT,GAAG,CAAE,CAAC,EAAE,CAAC,EAAE,CAAE,CAAC;IAC/BtB,aAAa,CAAC+B,EAAE,CAACR,YAAY,CAAE9B,cAAe,CAAC;IAC/CO,aAAa,CAAC+B,EAAE,CAACL,OAAO,CAAEpC,MAAO,CAAC;IAClCU,aAAa,CAACgC,MAAM,CAAEnC,MAAO,CAAC;IAE9BG,aAAa,CAACiC,GAAG,GAAGf,MAAM,CAACe,GAAG,CAAC,CAAC;;IAEhCjC,aAAa,CAACkC,iBAAiB,CAAC,CAAC;IACjClC,aAAa,CAACmC,gBAAgB,CAACL,IAAI,CAAEZ,MAAM,CAACiB,gBAAiB,CAAC;;IAE9D;IACApC,aAAa,CAACuB,GAAG,CAChB,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAClB,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAClB,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAClB,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAChB,CAAC;IACDvB,aAAa,CAACqC,QAAQ,CAAEpC,aAAa,CAACmC,gBAAiB,CAAC;IACxDpC,aAAa,CAACqC,QAAQ,CAAEpC,aAAa,CAACqC,kBAAmB,CAAC;IAC1DtC,aAAa,CAACqC,QAAQ,CAAEvD,KAAK,CAACuC,WAAY,CAAC;;IAE3C;IACA;IACA/B,cAAc,CAACiD,6BAA6B,CAAEhD,MAAM,EAAEC,sBAAuB,CAAC;IAC9EF,cAAc,CAACkC,YAAY,CAAEvB,aAAa,CAACqC,kBAAmB,CAAC;IAE/D1C,SAAS,CAAC2B,GAAG,CAAEjC,cAAc,CAACC,MAAM,CAACiD,CAAC,EAAElD,cAAc,CAACC,MAAM,CAACkD,CAAC,EAAEnD,cAAc,CAACC,MAAM,CAACmD,CAAC,EAAEpD,cAAc,CAACqD,QAAS,CAAC;IAEnH,IAAIP,gBAAgB,GAAGnC,aAAa,CAACmC,gBAAgB;IAErDrC,CAAC,CAACyC,CAAC,GAAG,CAAEI,IAAI,CAACC,IAAI,CAAEjD,SAAS,CAAC4C,CAAE,CAAC,GAAGJ,gBAAgB,CAACU,QAAQ,CAAE,CAAC,CAAE,IAAKV,gBAAgB,CAACU,QAAQ,CAAE,CAAC,CAAE;IACpG/C,CAAC,CAAC0C,CAAC,GAAG,CAAEG,IAAI,CAACC,IAAI,CAAEjD,SAAS,CAAC6C,CAAE,CAAC,GAAGL,gBAAgB,CAACU,QAAQ,CAAE,CAAC,CAAE,IAAKV,gBAAgB,CAACU,QAAQ,CAAE,CAAC,CAAE;IACpG/C,CAAC,CAAC2C,CAAC,GAAG,CAAE,GAAG;IACX3C,CAAC,CAACgD,CAAC,GAAG,CAAE,GAAG,GAAGX,gBAAgB,CAACU,QAAQ,CAAE,EAAE,CAAE,IAAKV,gBAAgB,CAACU,QAAQ,CAAE,EAAE,CAAE;;IAEjF;IACAlD,SAAS,CAACoD,cAAc,CAAE,GAAG,GAAGpD,SAAS,CAAC8B,GAAG,CAAE3B,CAAE,CAAE,CAAC;;IAEpD;IACAqC,gBAAgB,CAACU,QAAQ,CAAE,CAAC,CAAE,GAAGlD,SAAS,CAAC4C,CAAC;IAC5CJ,gBAAgB,CAACU,QAAQ,CAAE,CAAC,CAAE,GAAGlD,SAAS,CAAC6C,CAAC;IAC5CL,gBAAgB,CAACU,QAAQ,CAAE,EAAE,CAAE,GAAGlD,SAAS,CAAC8C,CAAC,GAAG,GAAG,GAAGvD,QAAQ;IAC9DiD,gBAAgB,CAACU,QAAQ,CAAE,EAAE,CAAE,GAAGlD,SAAS,CAACmD,CAAC;;IAE7C;;IAEAzC,YAAY,CAACE,OAAO,CAACyC,QAAQ,GAAGhC,QAAQ,CAACiC,cAAc;IAEvDpE,KAAK,CAACqE,OAAO,GAAG,KAAK;IAErB,IAAIC,mBAAmB,GAAGnC,QAAQ,CAACoC,eAAe,CAAC,CAAC;IAEpD,IAAIC,gBAAgB,GAAGrC,QAAQ,CAACsC,EAAE,CAACC,OAAO;IAC1C,IAAIC,uBAAuB,GAAGxC,QAAQ,CAACyC,SAAS,CAACC,UAAU;IAE3D1C,QAAQ,CAACsC,EAAE,CAACC,OAAO,GAAG,KAAK,CAAC,CAAC;IAC7BvC,QAAQ,CAACyC,SAAS,CAACC,UAAU,GAAG,KAAK,CAAC,CAAC;;IAEvC1C,QAAQ,CAAC2C,eAAe,CAAEtD,YAAa,CAAC;IAExCW,QAAQ,CAAC4C,KAAK,CAACC,OAAO,CAACC,KAAK,CAACC,OAAO,CAAE,IAAK,CAAC,CAAC,CAAC;;IAE9C,IAAK/C,QAAQ,CAACgD,SAAS,KAAK,KAAK,EAAGhD,QAAQ,CAACiD,KAAK,CAAC,CAAC;IACpDjD,QAAQ,CAACkD,MAAM,CAAEjD,KAAK,EAAEjB,aAAc,CAAC;IAEvCgB,QAAQ,CAACsC,EAAE,CAACC,OAAO,GAAGF,gBAAgB;IACtCrC,QAAQ,CAACyC,SAAS,CAACC,UAAU,GAAGF,uBAAuB;IAEvDxC,QAAQ,CAAC2C,eAAe,CAAER,mBAAoB,CAAC;;IAE/C;;IAEA,IAAIgB,QAAQ,GAAGjD,MAAM,CAACiD,QAAQ;IAE9B,IAAKA,QAAQ,KAAKpF,SAAS,EAAG;MAE7BiC,QAAQ,CAAC4C,KAAK,CAACO,QAAQ,CAAEA,QAAS,CAAC;IAEpC;IAEAtF,KAAK,CAACqE,OAAO,GAAG,IAAI;EAErB,CAAC;EAED,IAAI,CAACE,eAAe,GAAG,YAAY;IAElC,OAAO/C,YAAY;EAEpB,CAAC;AAEF,CAAC;AAED7B,SAAS,CAAC4F,SAAS,GAAGC,MAAM,CAACC,MAAM,CAAEvG,IAAI,CAACqG,SAAU,CAAC;AACrD5F,SAAS,CAAC4F,SAAS,CAACG,WAAW,GAAG/F,SAAS;AAE3CA,SAAS,CAACY,eAAe,GAAG;EAE3BsB,QAAQ,EAAE;IAET,OAAO,EAAE;MACRI,KAAK,EAAE;IACR,CAAC;IAED,UAAU,EAAE;MACXA,KAAK,EAAE;IACR,CAAC;IAED,eAAe,EAAE;MAChBA,KAAK,EAAE;IACR;EAED,CAAC;EAEDD,YAAY,EAAE,CACb,6BAA6B,EAC7B,mBAAmB,EAEnB,eAAe,EAEf,+CAA+C,EAE/C,4EAA4E,EAE5E,GAAG,CACH,CAAC2D,IAAI,CAAE,IAAK,CAAC;EAEd5D,cAAc,EAAE,CACf,qBAAqB,EACrB,6BAA6B,EAC7B,mBAAmB,EAEnB,iDAAiD,EAEjD,oGAAoG,EAEpG,GAAG,EAEH,8CAA8C,EAE9C,oHAAoH,EAEpH,GAAG,EAEH,eAAe,EAEf,8CAA8C,EAC9C,+DAA+D,EAE/D,GAAG,CACH,CAAC4D,IAAI,CAAE,IAAK;AACd,CAAC;AAED,SAAShG,SAAS"},"metadata":{},"sourceType":"module"}